import "./chunk-FAW2VN4A.js";

// node_modules/@fancyapps/ui/dist/fancybox/fancybox.esm.js
var t = (t2) => "object" == typeof t2 && null !== t2 && t2.constructor === Object && "[object Object]" === Object.prototype.toString.call(t2);
var e = (i2, ...n2) => {
  const s2 = n2.length;
  for (let o2 = 0; o2 < s2; o2++) {
    const s3 = n2[o2] || {};
    Object.entries(s3).forEach(([n3, s4]) => {
      const o3 = Array.isArray(s4) ? [] : {};
      i2[n3] || Object.assign(i2, { [n3]: o3 }), t(s4) ? Object.assign(i2[n3], e(o3, s4)) : Array.isArray(s4) ? Object.assign(i2, { [n3]: [...s4] }) : Object.assign(i2, { [n3]: s4 });
    });
  }
  return i2;
};
var i = function(t2) {
  return new DOMParser().parseFromString(t2, "text/html").body.firstChild;
};
var n = !("undefined" == typeof window || !window.document || !window.document.createElement);
var s;
var o = ["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'].join(",");
var a = '<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>';
var r = { PANUP: "Move up", PANDOWN: "Move down", PANLEFT: "Move left", PANRIGHT: "Move right", ZOOMIN: "Zoom in", ZOOMOUT: "Zoom out", TOGGLEZOOM: "Toggle zoom level", TOGGLE1TO1: "Toggle zoom level", ITERATEZOOM: "Toggle zoom level", ROTATECCW: "Rotate counterclockwise", ROTATECW: "Rotate clockwise", FLIPX: "Flip horizontally", FLIPY: "Flip vertically", FITX: "Fit horizontally", FITY: "Fit vertically", RESET: "Reset", TOGGLEFS: "Toggle fullscreen" };
var l = { dragToClose: true, hideScrollbar: true, Carousel: { classes: { container: "fancybox__carousel", viewport: "fancybox__viewport", track: "fancybox__track", slide: "fancybox__slide" } }, contentClick: "toggleZoom", contentDblClick: false, backdropClick: "close", animated: true, idle: 3500, showClass: "f-zoomInUp", hideClass: "f-fadeOut", commonCaption: false, parentEl: null, startIndex: 0, l10n: Object.assign(Object.assign({}, r), { CLOSE: "Close", NEXT: "Next", PREV: "Previous", MODAL: "You can close this modal content with the ESC key", ERROR: "Something Went Wrong, Please Try Again Later", IMAGE_ERROR: "Image Not Found", ELEMENT_NOT_FOUND: "HTML Element Not Found", AJAX_NOT_FOUND: "Error Loading AJAX : Not Found", AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden", IFRAME_ERROR: "Error Loading Page", TOGGLE_ZOOM: "Toggle zoom level", TOGGLE_THUMBS: "Toggle thumbnails", TOGGLE_SLIDESHOW: "Toggle slideshow", TOGGLE_FULLSCREEN: "Toggle full-screen mode", DOWNLOAD: "Download" }), tpl: { closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>', main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>' }, groupAll: false, groupAttr: "data-fancybox", defaultType: "image", defaultDisplay: "block", autoFocus: true, trapFocus: true, placeFocusBack: true, closeButton: "auto", keyboard: { Escape: "close", Delete: "close", Backspace: "close", PageUp: "next", PageDown: "prev", ArrowUp: "prev", ArrowDown: "next", ArrowRight: "next", ArrowLeft: "prev" }, Fullscreen: { autoStart: false }, compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches, wheel: "zoom" };
var c;
var h;
!function(t2) {
  t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Closing = 2] = "Closing", t2[t2.CustomClosing = 3] = "CustomClosing", t2[t2.Destroy = 4] = "Destroy";
}(c || (c = {})), function(t2) {
  t2[t2.Loading = 0] = "Loading", t2[t2.Opening = 1] = "Opening", t2[t2.Ready = 2] = "Ready", t2[t2.Closing = 3] = "Closing";
}(h || (h = {}));
var d = function(t2, e2) {
  return t2.split(".").reduce((t3, e3) => "object" == typeof t3 ? t3[e3] : void 0, e2);
};
var u = class {
  constructor(t2 = {}) {
    Object.defineProperty(this, "options", { enumerable: true, configurable: true, writable: true, value: t2 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() }), this.setOptions(t2);
    for (const t3 of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))
      t3.startsWith("on") && "function" == typeof this[t3] && (this[t3] = this[t3].bind(this));
  }
  setOptions(t2) {
    this.options = t2 ? e({}, this.constructor.defaults, t2) : {};
    for (const [t3, e2] of Object.entries(this.option("on") || {}))
      this.on(t3, e2);
  }
  option(t2, ...e2) {
    let i2 = d(t2, this.options);
    return i2 && "function" == typeof i2 && (i2 = i2.call(this, this, ...e2)), i2;
  }
  optionFor(t2, e2, i2, ...n2) {
    let s2 = d(e2, t2);
    var o2;
    "string" != typeof (o2 = s2) || isNaN(o2) || isNaN(parseFloat(o2)) || (s2 = parseFloat(s2)), "true" === s2 && (s2 = true), "false" === s2 && (s2 = false), s2 && "function" == typeof s2 && (s2 = s2.call(this, this, t2, ...n2));
    let a2 = d(e2, this.options);
    return a2 && "function" == typeof a2 ? s2 = a2.call(this, this, t2, ...n2, s2) : void 0 === s2 && (s2 = a2), void 0 === s2 ? i2 : s2;
  }
  cn(t2) {
    const e2 = this.options.classes;
    return e2 && e2[t2] || "";
  }
  localize(t2, e2 = []) {
    t2 = String(t2).replace(/\{\{(\w+).?(\w+)?\}\}/g, (t3, e3, i2) => {
      let n2 = "";
      return i2 ? n2 = this.option(`${e3[0] + e3.toLowerCase().substring(1)}.l10n.${i2}`) : e3 && (n2 = this.option(`l10n.${e3}`)), n2 || (n2 = t3), n2;
    });
    for (let i2 = 0; i2 < e2.length; i2++)
      t2 = t2.split(e2[i2][0]).join(e2[i2][1]);
    return t2 = t2.replace(/\{\{(.*)\}\}/, (t3, e3) => e3);
  }
  on(t2, e2) {
    let i2 = [];
    "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), this.events || (this.events = /* @__PURE__ */ new Map()), i2.forEach((t3) => {
      let i3 = this.events.get(t3);
      i3 || (this.events.set(t3, []), i3 = []), i3.includes(e2) || i3.push(e2), this.events.set(t3, i3);
    });
  }
  off(t2, e2) {
    let i2 = [];
    "string" == typeof t2 ? i2 = t2.split(" ") : Array.isArray(t2) && (i2 = t2), i2.forEach((t3) => {
      const i3 = this.events.get(t3);
      if (Array.isArray(i3)) {
        const t4 = i3.indexOf(e2);
        t4 > -1 && i3.splice(t4, 1);
      }
    });
  }
  emit(t2, ...e2) {
    [...this.events.get(t2) || []].forEach((t3) => t3(this, ...e2)), "*" !== t2 && this.emit("*", t2, ...e2);
  }
};
Object.defineProperty(u, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.7" }), Object.defineProperty(u, "defaults", { enumerable: true, configurable: true, writable: true, value: {} });
var p = class extends u {
  constructor(t2 = {}) {
    super(t2), Object.defineProperty(this, "plugins", { enumerable: true, configurable: true, writable: true, value: {} });
  }
  attachPlugins(t2 = {}) {
    const e2 = /* @__PURE__ */ new Map();
    for (const [i2, n2] of Object.entries(t2)) {
      const t3 = this.option(i2), s2 = this.plugins[i2];
      s2 || false === t3 ? s2 && false === t3 && (s2.detach(), delete this.plugins[i2]) : e2.set(i2, new n2(this, t3 || {}));
    }
    for (const [t3, i2] of e2)
      this.plugins[t3] = i2, i2.attach();
    this.emit("attachPlugins");
  }
  detachPlugins() {
    for (const t2 of Object.values(this.plugins))
      t2.detach();
    return this.plugins = {}, this.emit("detachPlugins"), this;
  }
};
var m = class extends u {
  constructor(t2, e2) {
    super(e2), Object.defineProperty(this, "instance", { enumerable: true, configurable: true, writable: true, value: t2 });
  }
  attach() {
  }
  detach() {
  }
};
var f = () => {
  queueMicrotask(() => {
    (() => {
      const { slug: t2, index: e2 } = g.parseURL(), i2 = vt.getInstance();
      if (i2 && false !== i2.option("Hash")) {
        const n2 = i2.carousel;
        if (t2 && n2) {
          for (let e3 of n2.slides)
            if (e3.slug && e3.slug === t2)
              return n2.slideTo(e3.index);
          if (t2 === i2.option("slug"))
            return n2.slideTo(e2 - 1);
          const s2 = i2.getSlide(), o2 = s2 && s2.triggerEl && s2.triggerEl.dataset;
          if (o2 && o2.fancybox === t2)
            return n2.slideTo(e2 - 1);
        }
        g.hasSilentClose = true, i2.close();
      }
      g.startFromUrl();
    })();
  });
};
var g = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "origHash", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null });
  }
  onChange() {
    const t2 = this.instance, e2 = t2.carousel;
    this.timer && clearTimeout(this.timer);
    const i2 = t2.getSlide();
    if (!e2 || !i2)
      return;
    const n2 = t2.isOpeningSlide(i2), s2 = new URL(document.URL).hash;
    let o2, a2 = i2.slug || void 0;
    o2 = a2 || this.instance.option("slug"), !o2 && i2.triggerEl && i2.triggerEl.dataset && (o2 = i2.triggerEl.dataset.fancybox);
    let r2 = "";
    o2 && "true" !== o2 && (r2 = "#" + o2 + (!a2 && e2.slides.length > 1 ? "-" + (i2.index + 1) : "")), n2 && (this.origHash = s2 !== r2 ? s2 : ""), r2 && s2 !== r2 && (this.timer = setTimeout(() => {
      try {
        window.history[n2 ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + r2);
      } catch (t3) {
      }
    }, 300));
  }
  onClose() {
    if (this.timer && clearTimeout(this.timer), true !== g.hasSilentClose)
      try {
        window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
      } catch (t2) {
      }
  }
  attach() {
    this.instance.on("Carousel.ready", this.onChange), this.instance.on("Carousel.change", this.onChange), this.instance.on("close", this.onClose);
  }
  detach() {
    this.instance.off("Carousel.ready", this.onChange), this.instance.off("Carousel.change", this.onChange), this.instance.off("close", this.onClose);
  }
  static parseURL() {
    const t2 = window.location.hash.slice(1), e2 = t2.split("-"), i2 = e2[e2.length - 1], n2 = i2 && /^\+?\d+$/.test(i2) && parseInt(e2.pop() || "1", 10) || 1;
    return { hash: t2, slug: e2.join("-"), index: n2 };
  }
  static startFromUrl() {
    if (g.hasSilentClose = false, vt.getInstance() || false === vt.defaults.Hash)
      return;
    const { hash: t2, slug: e2, index: i2 } = g.parseURL();
    if (!e2)
      return;
    let n2 = document.querySelector(`[data-slug="${t2}"]`);
    if (n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })), vt.getInstance())
      return;
    const s2 = document.querySelectorAll(`[data-fancybox="${e2}"]`);
    s2.length && (n2 = s2[i2 - 1], n2 && n2.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true })));
  }
  static destroy() {
    window.removeEventListener("hashchange", f, false);
  }
};
function b() {
  window.addEventListener("hashchange", f, false), setTimeout(() => {
    g.startFromUrl();
  }, 500);
}
Object.defineProperty(g, "defaults", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(g, "hasSilentClose", { enumerable: true, configurable: true, writable: true, value: false }), n && (/complete|interactive|loaded/.test(document.readyState) ? b() : document.addEventListener("DOMContentLoaded", b));
var v = (t2, e2 = 1e4) => (t2 = parseFloat(t2 + "") || 0, Math.round((t2 + Number.EPSILON) * e2) / e2);
var y = function(t2, e2) {
  return !(!t2 || t2 === document.body || e2 && t2 === e2) && (function(t3) {
    if (!(t3 && t3 instanceof Element && t3.offsetParent))
      return false;
    const e3 = t3.scrollHeight > t3.clientHeight, i2 = window.getComputedStyle(t3).overflowY, n2 = -1 !== i2.indexOf("hidden"), s2 = -1 !== i2.indexOf("visible");
    return e3 && !n2 && !s2;
  }(t2) ? t2 : y(t2.parentElement, e2));
};
var w = (t2) => `${t2 || ""}`.split(" ").filter((t3) => !!t3);
var x = (t2, e2, i2) => {
  w(e2).forEach((e3) => {
    t2 && t2.classList.toggle(e3, i2 || false);
  });
};
var S = class {
  constructor(t2) {
    Object.defineProperty(this, "pageX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "pageY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "clientY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "nativePointer", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.nativePointer = t2, this.pageX = t2.pageX, this.pageY = t2.pageY, this.clientX = t2.clientX, this.clientY = t2.clientY, this.id = self.Touch && t2 instanceof Touch ? t2.identifier : -1, this.time = Date.now();
  }
};
var E = { passive: false };
var P = class {
  constructor(t2, { start: e2 = () => true, move: i2 = () => {
  }, end: n2 = () => {
  } }) {
    Object.defineProperty(this, "element", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "startCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "moveCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "endCallback", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "currentPointers", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "startPointers", { enumerable: true, configurable: true, writable: true, value: [] }), this.element = t2, this.startCallback = e2, this.moveCallback = i2, this.endCallback = n2;
    for (const t3 of ["onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur"])
      this[t3] = this[t3].bind(this);
    this.element.addEventListener("mousedown", this.onPointerStart, E), this.element.addEventListener("touchstart", this.onTouchStart, E), this.element.addEventListener("touchmove", this.onMove, E), this.element.addEventListener("touchend", this.onTouchEnd), this.element.addEventListener("touchcancel", this.onTouchEnd);
  }
  onPointerStart(t2) {
    if (!t2.buttons || 0 !== t2.button)
      return;
    const e2 = new S(t2);
    this.currentPointers.some((t3) => t3.id === e2.id) || this.triggerPointerStart(e2, t2) && (window.addEventListener("mousemove", this.onMove), window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
  }
  onTouchStart(t2) {
    for (const e2 of Array.from(t2.changedTouches || []))
      this.triggerPointerStart(new S(e2), t2);
    window.addEventListener("blur", this.onWindowBlur);
  }
  onMove(t2) {
    const e2 = this.currentPointers.slice(), i2 = "changedTouches" in t2 ? Array.from(t2.changedTouches || []).map((t3) => new S(t3)) : [new S(t2)], n2 = [];
    for (const t3 of i2) {
      const e3 = this.currentPointers.findIndex((e4) => e4.id === t3.id);
      e3 < 0 || (n2.push(t3), this.currentPointers[e3] = t3);
    }
    n2.length && this.moveCallback(t2, this.currentPointers.slice(), e2);
  }
  onPointerEnd(t2) {
    t2.buttons > 0 && 0 !== t2.button || (this.triggerPointerEnd(t2, new S(t2)), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
  }
  onTouchEnd(t2) {
    for (const e2 of Array.from(t2.changedTouches || []))
      this.triggerPointerEnd(t2, new S(e2));
  }
  triggerPointerStart(t2, e2) {
    return !!this.startCallback(e2, t2, this.currentPointers.slice()) && (this.currentPointers.push(t2), this.startPointers.push(t2), true);
  }
  triggerPointerEnd(t2, e2) {
    const i2 = this.currentPointers.findIndex((t3) => t3.id === e2.id);
    i2 < 0 || (this.currentPointers.splice(i2, 1), this.startPointers.splice(i2, 1), this.endCallback(t2, e2, this.currentPointers.slice()));
  }
  onWindowBlur() {
    this.clear();
  }
  clear() {
    for (; this.currentPointers.length; ) {
      const t2 = this.currentPointers[this.currentPointers.length - 1];
      this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), this.endCallback(new Event("touchend", { bubbles: true, cancelable: true, clientX: t2.clientX, clientY: t2.clientY }), t2, this.currentPointers.slice());
    }
  }
  stop() {
    this.element.removeEventListener("mousedown", this.onPointerStart, E), this.element.removeEventListener("touchstart", this.onTouchStart, E), this.element.removeEventListener("touchmove", this.onMove, E), this.element.removeEventListener("touchend", this.onTouchEnd), this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
  }
};
function M(t2, e2) {
  return e2 ? Math.sqrt(Math.pow(e2.clientX - t2.clientX, 2) + Math.pow(e2.clientY - t2.clientY, 2)) : 0;
}
function C(t2, e2) {
  return e2 ? { clientX: (t2.clientX + e2.clientX) / 2, clientY: (t2.clientY + e2.clientY) / 2 } : t2;
}
var T;
!function(t2) {
  t2[t2.Init = 0] = "Init", t2[t2.Error = 1] = "Error", t2[t2.Ready = 2] = "Ready", t2[t2.Panning = 3] = "Panning", t2[t2.Mousemove = 4] = "Mousemove", t2[t2.Destroy = 5] = "Destroy";
}(T || (T = {}));
var O = ["a", "b", "c", "d", "e", "f"];
var A = { content: null, width: "auto", height: "auto", panMode: "drag", touch: true, dragMinThreshold: 3, lockAxis: false, mouseMoveFactor: 1, mouseMoveFriction: 0.12, zoom: true, pinchToZoom: true, panOnlyZoomed: "auto", minScale: 1, maxScale: 2, friction: 0.25, dragFriction: 0.35, decelFriction: 0.05, click: "toggleZoom", dblClick: false, wheel: "zoom", wheelLimit: 7, spinner: true, bounds: "auto", infinite: false, rubberband: true, bounce: true, maxVelocity: 75, transformParent: false, classes: { content: "f-panzoom__content", isLoading: "is-loading", canZoomIn: "can-zoom_in", canZoomOut: "can-zoom_out", isDraggable: "is-draggable", isDragging: "is-dragging", inFullscreen: "in-fullscreen", htmlHasFullscreen: "with-panzoom-in-fullscreen" }, l10n: r };
var L = (t2) => t2 && null !== t2 && t2 instanceof Element && "nodeType" in t2;
var z = (t2, e2) => {
  w(e2).forEach((e3) => {
    t2 && t2.classList.remove(e3);
  });
};
var R = (t2, e2) => {
  w(e2).forEach((e3) => {
    t2 && t2.classList.add(e3);
  });
};
var k = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
var I = null;
var D = null;
var F = class extends p {
  get isTouchDevice() {
    return null === D && (D = window.matchMedia("(hover: none)").matches), D;
  }
  get isMobile() {
    return null === I && (I = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), I;
  }
  get panMode() {
    return "mousemove" !== this.options.panMode || this.isTouchDevice ? "drag" : "mousemove";
  }
  get panOnlyZoomed() {
    const t2 = this.options.panOnlyZoomed;
    return "auto" === t2 ? this.isTouchDevice : t2;
  }
  get isInfinite() {
    return this.option("infinite");
  }
  get angle() {
    return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
  }
  get targetAngle() {
    return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
  }
  get scale() {
    const { a: t2, b: e2 } = this.current;
    return Math.sqrt(t2 * t2 + e2 * e2) || 1;
  }
  get targetScale() {
    const { a: t2, b: e2 } = this.target;
    return Math.sqrt(t2 * t2 + e2 * e2) || 1;
  }
  get minScale() {
    return this.option("minScale") || 1;
  }
  get fullScale() {
    const { contentRect: t2 } = this;
    return t2.fullWidth / t2.fitWidth || 1;
  }
  get maxScale() {
    return this.fullScale * (this.option("maxScale") || 1) || 1;
  }
  get coverScale() {
    const { containerRect: t2, contentRect: e2 } = this, i2 = Math.max(t2.height / e2.fitHeight, t2.width / e2.fitWidth) || 1;
    return Math.min(this.fullScale, i2);
  }
  get isScaling() {
    return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
  }
  get isContentLoading() {
    const t2 = this.content;
    return !!(t2 && t2 instanceof HTMLImageElement) && !t2.complete;
  }
  get isResting() {
    if (this.isBouncingX || this.isBouncingY)
      return false;
    for (const t2 of O) {
      const e2 = "e" == t2 || "f" === t2 ? 1e-3 : 1e-5;
      if (Math.abs(this.target[t2] - this.current[t2]) > e2)
        return false;
    }
    return !(!this.ignoreBounds && !this.checkBounds().inBounds);
  }
  constructor(t2, e2 = {}, n2 = {}) {
    var s2;
    if (super(e2), Object.defineProperty(this, "pointerTracker", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "resizeObserver", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "updateTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "rAF", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "isTicking", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "friction", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreBounds", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingX", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "isBouncingY", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "clicks", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "trackingPoints", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "wheelDelta", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevWheelDelta", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevWheelTime", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevMouseMoveEvent", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: T.Init }), Object.defineProperty(this, "isDragging", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "content", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "spinner", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "containerRect", { enumerable: true, configurable: true, writable: true, value: { width: 0, height: 0, innerWidth: 0, innerHeight: 0 } }), Object.defineProperty(this, "contentRect", { enumerable: true, configurable: true, writable: true, value: { top: 0, right: 0, bottom: 0, left: 0, fullWidth: 0, fullHeight: 0, fitWidth: 0, fitHeight: 0, width: 0, height: 0 } }), Object.defineProperty(this, "dragStart", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, top: 0, left: 0, time: 0 } }), Object.defineProperty(this, "dragOffset", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0, time: 0 } }), Object.defineProperty(this, "current", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, k) }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: Object.assign({}, k) }), Object.defineProperty(this, "velocity", { enumerable: true, configurable: true, writable: true, value: { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0 } }), Object.defineProperty(this, "lockedAxis", { enumerable: true, configurable: true, writable: true, value: false }), !t2)
      throw new Error("No Element found");
    if (this.container = t2, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, F.Plugins), n2)), this.emit("init"), this.isContentLoading) {
      const e3 = this.content;
      if (this.option("spinner")) {
        t2.classList.add(this.cn("isLoading"));
        const n3 = i(a);
        t2.contains(e3) ? this.spinner = (null === (s2 = e3.parentElement) || void 0 === s2 ? void 0 : s2.insertBefore(n3, e3)) || null : this.spinner = t2.appendChild(n3);
      }
      this.emit("beforeLoad"), e3.addEventListener("load", this.onLoad), e3.addEventListener("error", this.onError);
    } else
      queueMicrotask(() => {
        this.enable();
      });
  }
  initContent() {
    const { container: t2 } = this;
    let e2 = this.option("content") || t2.querySelector(`.${this.cn("content")}`);
    if (e2 || (e2 = t2.querySelector("img") || t2.firstElementChild, e2 && e2.classList.add(this.cn("content"))), !e2)
      throw new Error("No content found");
    this.content = e2;
  }
  onLoad() {
    this.spinner && (this.spinner.remove(), this.spinner = null), this.option("spinner") && this.container.classList.remove(this.cn("isLoading")), this.emit("afterLoad"), this.state === T.Init && this.enable();
  }
  onError() {
    this.state !== T.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), this.stop(), this.detachEvents(), this.state = T.Error, this.emit("error"));
  }
  attachObserver() {
    var t2;
    const e2 = () => Math.abs(this.containerRect.width - this.container.getBoundingClientRect().width) > 0.1 || Math.abs(this.containerRect.height - this.container.getBoundingClientRect().height) > 0.1;
    this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver(() => {
      this.updateTimer || (e2() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout(() => {
        e2() && this.onResize(), this.updateTimer = null;
      }, 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
    })), null === (t2 = this.resizeObserver) || void 0 === t2 || t2.observe(this.container);
  }
  detachObserver() {
    var t2;
    null === (t2 = this.resizeObserver) || void 0 === t2 || t2.disconnect();
  }
  attachEvents() {
    const { container: t2 } = this;
    t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("wheel", this.onWheel, { passive: false }), this.pointerTracker = new P(t2, { start: this.onPointerDown, move: this.onPointerMove, end: this.onPointerUp }), document.addEventListener("mousemove", this.onMouseMove);
  }
  detachEvents() {
    var t2;
    const { container: e2 } = this;
    e2.removeEventListener("click", this.onClick, { passive: false, capture: false }), e2.removeEventListener("wheel", this.onWheel, { passive: false }), null === (t2 = this.pointerTracker) || void 0 === t2 || t2.stop(), this.pointerTracker = null, document.removeEventListener("mousemove", this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, true), this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null);
  }
  animate() {
    this.setTargetForce();
    const t2 = this.option("maxVelocity");
    for (const e2 of O)
      this.friction ? (this.velocity[e2] *= 1 - this.friction, t2 && !this.isScaling && (this.velocity[e2] = Math.max(Math.min(this.velocity[e2], t2), -1 * t2)), this.current[e2] += this.velocity[e2]) : this.current[e2] = this.target[e2];
    this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame(() => this.animate()) : this.stop("current");
  }
  setTargetForce() {
    for (const t2 of O)
      "e" === t2 && this.isBouncingX || "f" === t2 && this.isBouncingY || (this.velocity[t2] = (1 / (1 - this.friction) - 1) * (this.target[t2] - this.current[t2]));
  }
  checkBounds(t2 = 0, e2 = 0) {
    const { current: i2 } = this, n2 = i2.e + t2, s2 = i2.f + e2, o2 = this.getBounds(), { x: a2, y: r2 } = o2, l2 = a2.min, c2 = a2.max, h2 = r2.min, d2 = r2.max;
    let u2 = 0, p2 = 0;
    return l2 !== 1 / 0 && n2 < l2 ? u2 = l2 - n2 : c2 !== 1 / 0 && n2 > c2 && (u2 = c2 - n2), h2 !== 1 / 0 && s2 < h2 ? p2 = h2 - s2 : d2 !== 1 / 0 && s2 > d2 && (p2 = d2 - s2), Math.abs(u2) < 1e-3 && (u2 = 0), Math.abs(p2) < 1e-3 && (p2 = 0), Object.assign(Object.assign({}, o2), { xDiff: u2, yDiff: p2, inBounds: !u2 && !p2 });
  }
  clampTargetBounds() {
    const { target: t2 } = this, { x: e2, y: i2 } = this.getBounds();
    e2.min !== 1 / 0 && (t2.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (t2.e = Math.min(t2.e, e2.max)), i2.min !== 1 / 0 && (t2.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (t2.f = Math.min(t2.f, i2.max));
  }
  calculateContentDim(t2 = this.current) {
    const { content: e2, contentRect: i2 } = this, { fitWidth: n2, fitHeight: s2, fullWidth: o2, fullHeight: a2 } = i2;
    let r2 = o2, l2 = a2;
    if (this.option("zoom") || 0 !== this.angle) {
      const i3 = !(e2 instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e2).maxWidth || "none" === window.getComputedStyle(e2).maxHeight), c2 = i3 ? o2 : n2, h2 = i3 ? a2 : s2, d2 = this.getMatrix(t2), u2 = new DOMPoint(0, 0).matrixTransform(d2), p2 = new DOMPoint(0 + c2, 0).matrixTransform(d2), m2 = new DOMPoint(0 + c2, 0 + h2).matrixTransform(d2), f2 = new DOMPoint(0, 0 + h2).matrixTransform(d2), g2 = Math.abs(m2.x - u2.x), b2 = Math.abs(m2.y - u2.y), v2 = Math.abs(f2.x - p2.x), y2 = Math.abs(f2.y - p2.y);
      r2 = Math.max(g2, v2), l2 = Math.max(b2, y2);
    }
    return { contentWidth: r2, contentHeight: l2 };
  }
  setEdgeForce() {
    if (this.ignoreBounds || this.isDragging || "mousemove" === this.panMode || this.targetScale < this.scale)
      return this.isBouncingX = false, void (this.isBouncingY = false);
    const { target: t2 } = this, { x: e2, y: i2, xDiff: n2, yDiff: s2 } = this.checkBounds();
    const o2 = this.option("maxVelocity");
    let a2 = this.velocity.e, r2 = this.velocity.f;
    0 !== n2 ? (this.isBouncingX = true, n2 * a2 <= 0 ? a2 += 0.14 * n2 : (a2 = 0.14 * n2, e2.min !== 1 / 0 && (this.target.e = Math.max(t2.e, e2.min)), e2.max !== 1 / 0 && (this.target.e = Math.min(t2.e, e2.max))), o2 && (a2 = Math.max(Math.min(a2, o2), -1 * o2))) : this.isBouncingX = false, 0 !== s2 ? (this.isBouncingY = true, s2 * r2 <= 0 ? r2 += 0.14 * s2 : (r2 = 0.14 * s2, i2.min !== 1 / 0 && (this.target.f = Math.max(t2.f, i2.min)), i2.max !== 1 / 0 && (this.target.f = Math.min(t2.f, i2.max))), o2 && (r2 = Math.max(Math.min(r2, o2), -1 * o2))) : this.isBouncingY = false, this.isBouncingX && (this.velocity.e = a2), this.isBouncingY && (this.velocity.f = r2);
  }
  enable() {
    const { content: t2 } = this, e2 = new DOMMatrixReadOnly(window.getComputedStyle(t2).transform);
    for (const t3 of O)
      this.current[t3] = this.target[t3] = e2[t3];
    this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = T.Ready, this.emit("ready");
  }
  onClick(t2) {
    var e2;
    this.isDragging && (null === (e2 = this.pointerTracker) || void 0 === e2 || e2.clear(), this.trackingPoints = [], this.startDecelAnim());
    const i2 = t2.target;
    if (!i2 || t2.defaultPrevented)
      return;
    if (i2 && i2.hasAttribute("disabled"))
      return t2.preventDefault(), void t2.stopPropagation();
    if ((() => {
      const t3 = window.getSelection();
      return t3 && "Range" === t3.type;
    })() && !i2.closest("button"))
      return;
    const n2 = i2.closest("[data-panzoom-action]"), s2 = i2.closest("[data-panzoom-change]"), o2 = n2 || s2, a2 = o2 && L(o2) ? o2.dataset : null;
    if (a2) {
      const e3 = a2.panzoomChange, i3 = a2.panzoomAction;
      if ((e3 || i3) && t2.preventDefault(), e3) {
        let t3 = {};
        try {
          t3 = JSON.parse(e3);
        } catch (t4) {
          console && console.warn("The given data was not valid JSON");
        }
        return void this.applyChange(t3);
      }
      if (i3)
        return void (this[i3] && this[i3]());
    }
    if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3)
      return t2.preventDefault(), void t2.stopPropagation();
    const r2 = this.content.getBoundingClientRect();
    if (this.dragStart.time && !this.canZoomOut() && (Math.abs(r2.x - this.dragStart.x) > 2 || Math.abs(r2.y - this.dragStart.y) > 2))
      return;
    this.dragStart.time = 0;
    const l2 = (e3) => {
      !this.option("zoom") || Math.abs(this.velocity.a) > 0.3 || e3 && "string" == typeof e3 && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e3) && "function" == typeof this[e3] && (t2.preventDefault(), this[e3]({ event: t2 }));
    }, c2 = this.option("click", t2), h2 = this.option("dblClick", t2);
    h2 ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout(() => {
      1 === this.clicks ? (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2)) : (this.emit("dblClick", t2), t2.defaultPrevented || l2(h2)), this.clicks = 0, this.clickTimer = null;
    }, 350))) : (this.emit("click", t2), !t2.defaultPrevented && c2 && l2(c2));
  }
  addTrackingPoint(t2) {
    const e2 = this.trackingPoints.filter((t3) => t3.time > Date.now() - 100);
    e2.push(t2), this.trackingPoints = e2;
  }
  onPointerDown(t2, e2, i2) {
    var n2;
    this.dragOffset = { x: 0, y: 0, time: 0 }, this.trackingPoints = [];
    const s2 = this.content.getBoundingClientRect();
    if (this.dragStart = { x: s2.x, y: s2.y, top: s2.top, left: s2.left, time: Date.now() }, this.clickTimer)
      return false;
    if ("mousemove" === this.panMode && this.targetScale > 1)
      return t2.preventDefault(), t2.stopPropagation(), false;
    if (!i2.length) {
      const e3 = t2.composedPath()[0];
      if (["A", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].includes(e3.nodeName) || e3.closest("[contenteditable]") || e3.closest("[data-selectable]") || e3.closest("[data-panzoom-change]") || e3.closest("[data-panzoom-action]"))
        return false;
      null === (n2 = window.getSelection()) || void 0 === n2 || n2.removeAllRanges();
    }
    return "mousedown" === t2.type && t2.preventDefault(), v(this.targetScale, 1e3) === v(this.minScale, 1e3) ? (this.stop(), this.target.e = this.current.e, this.target.f = this.current.f) : this.stop("target"), this.isDragging = true, this.addTrackingPoint(e2), this.emit("touchStart", t2), true;
  }
  onPointerMove(t2, e2, i2) {
    if (false === this.option("touch", t2))
      return;
    if (!this.isDragging)
      return;
    if (e2.length < 2 && this.panOnlyZoomed && v(this.targetScale) <= v(this.minScale))
      return;
    if (this.emit("touchMove", t2), t2.defaultPrevented)
      return;
    this.addTrackingPoint(e2[0]);
    const { content: n2 } = this, s2 = C(i2[0], i2[1]), o2 = C(e2[0], e2[1]);
    let a2 = 0, r2 = 0;
    if (e2.length > 1) {
      const t3 = n2.getBoundingClientRect();
      a2 = s2.clientX - t3.left - 0.5 * t3.width, r2 = s2.clientY - t3.top - 0.5 * t3.height;
    }
    const l2 = M(i2[0], i2[1]), c2 = M(e2[0], e2[1]);
    let h2 = l2 ? c2 / l2 : 1, d2 = o2.clientX - s2.clientX, u2 = o2.clientY - s2.clientY;
    this.dragOffset.x += d2, this.dragOffset.y += u2, this.dragOffset.time = Date.now() - this.dragStart.time;
    let p2 = v(this.targetScale) === v(this.minScale) && this.option("lockAxis");
    if (p2 && !this.lockedAxis)
      if ("xy" === p2 || "y" === p2 || "touchmove" === t2.type) {
        if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6)
          return void t2.preventDefault();
        const e3 = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
        this.lockedAxis = e3 > 45 && e3 < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, d2 = 0, u2 = 0;
      } else
        this.lockedAxis = p2;
    if (y(t2.target, this.content) && (p2 = "x", this.dragOffset.y = 0), p2 && "xy" !== p2 && this.lockedAxis !== p2 && v(this.targetScale) === v(this.minScale))
      return;
    t2.cancelable && t2.preventDefault(), this.container.classList.add(this.cn("isDragging"));
    const m2 = this.checkBounds(d2, u2);
    this.option("rubberband") ? ("x" !== this.isInfinite && (m2.xDiff > 0 && d2 < 0 || m2.xDiff < 0 && d2 > 0) && (d2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitWidth * m2.xDiff))), "y" !== this.isInfinite && (m2.yDiff > 0 && u2 < 0 || m2.yDiff < 0 && u2 > 0) && (u2 *= Math.max(0, 0.5 - Math.abs(0.75 / this.contentRect.fitHeight * m2.yDiff)))) : (m2.xDiff && (d2 = 0), m2.yDiff && (u2 = 0));
    const f2 = this.targetScale, g2 = this.minScale, b2 = this.maxScale;
    f2 < 0.5 * g2 && (h2 = Math.max(h2, g2)), f2 > 1.5 * b2 && (h2 = Math.min(h2, b2)), "y" === this.lockedAxis && v(f2) === v(g2) && (d2 = 0), "x" === this.lockedAxis && v(f2) === v(g2) && (u2 = 0), this.applyChange({ originX: a2, originY: r2, panX: d2, panY: u2, scale: h2, friction: this.option("dragFriction"), ignoreBounds: true });
  }
  onPointerUp(t2, e2, i2) {
    if (i2.length)
      return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
    this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e2), this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), y(t2.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), this.emit("touchEnd", t2), this.isDragging = false, this.lockedAxis = false, this.state !== T.Destroy && (t2.defaultPrevented || this.startDecelAnim()));
  }
  startDecelAnim() {
    this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
    for (const t3 of O)
      this.velocity[t3] = 0, this.target[t3] = this.current[t3];
    z(this.container, "is-scaling"), z(this.container, "is-animating"), this.isTicking = false;
    const { trackingPoints: t2 } = this, e2 = t2[0], i2 = t2[t2.length - 1];
    let n2 = 0, s2 = 0, o2 = 0;
    i2 && e2 && (n2 = i2.clientX - e2.clientX, s2 = i2.clientY - e2.clientY, o2 = i2.time - e2.time);
    let a2 = 0, r2 = 0, l2 = 0, c2 = 0, h2 = this.option("decelFriction");
    const d2 = this.targetScale;
    if ((d2 < this.minScale - 1e-5 || d2 > this.maxScale + 1e-5) && (h2 = 0.35), o2 > 0) {
      l2 = Math.abs(n2) > 3 ? n2 / (o2 / 30) : 0, c2 = Math.abs(s2) > 3 ? s2 / (o2 / 30) : 0;
      const t3 = this.option("maxVelocity");
      t3 && (l2 = Math.max(Math.min(l2, t3), -1 * t3), c2 = Math.max(Math.min(c2, t3), -1 * t3));
    }
    l2 && (a2 = l2 / (1 / (1 - h2) - 1)), c2 && (r2 = c2 / (1 / (1 - h2) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && v(d2) === this.minScale) && (a2 = l2 = 0), ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && v(d2) === this.minScale) && (r2 = c2 = 0);
    const u2 = this.dragOffset.x, p2 = this.dragOffset.y, m2 = this.option("dragMinThreshold") || 0;
    Math.abs(u2) < m2 && Math.abs(p2) < m2 && (a2 = r2 = 0, l2 = c2 = 0), this.applyChange({ panX: a2, panY: r2, friction: h2 }), this.emit("decel", l2, c2, u2, p2);
  }
  onWheel(t2) {
    const e2 = Date.now(), i2 = Math.max(-1, Math.min(1, -t2.deltaY || -t2.deltaX || -t2.detail));
    if (this.prevWheelTime && e2 - this.prevWheelTime < 200 && this.prevWheelDelta !== i2)
      return void t2.preventDefault();
    if (this.prevWheelDelta = i2, this.prevWheelTime = e2, this.emit("wheel", t2, i2), "mousemove" === this.panMode)
      return;
    if (t2.defaultPrevented)
      return;
    const n2 = this.option("wheel");
    "pan" === n2 ? (t2.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({ panY: 100 * i2, bounce: false })) : "zoom" === n2 && false !== this.option("zoom") && this.zoomWithWheel(t2);
  }
  onMouseMove(t2) {
    this.panWithMouse(t2);
  }
  onKeydown(t2) {
    "Escape" === t2.key && this.toggleFS();
  }
  onResize() {
    this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
  }
  setTransform() {
    this.emit("beforeTransform");
    const { current: t2, target: e2, content: i2, contentRect: n2 } = this, s2 = Object.assign({}, k);
    for (const i3 of O) {
      const n3 = "e" == i3 || "f" === i3 ? 1e3 : 1e5;
      s2[i3] = v(t2[i3], n3), Math.abs(e2[i3] - t2[i3]) < ("e" == i3 || "f" === i3 ? 0.51 : 1e-3) && (this.current[i3] = e2[i3]);
    }
    const { a: o2, b: a2, c: r2, d: l2, e: c2, f: h2 } = s2, d2 = `matrix(${o2}, ${a2}, ${r2}, ${l2}, ${c2}, ${h2})`, u2 = (this.option("transformParent") ? i2.parentElement : null) || i2;
    if (u2.style.transform === d2)
      return;
    u2.style.transform = d2;
    const { contentWidth: p2, contentHeight: m2 } = this.calculateContentDim();
    n2.width = p2, n2.height = m2, this.emit("afterTransform");
  }
  updateMetrics(t2 = false) {
    if (!this || this.state === T.Destroy)
      return;
    const { container: e2, containerRect: i2, content: n2 } = this, s2 = i2.innerWidth, o2 = i2.innerHeight, a2 = e2.getBoundingClientRect(), r2 = getComputedStyle(this.container), l2 = a2.width, c2 = a2.height, h2 = parseFloat(r2.paddingTop) + parseFloat(r2.paddingBottom), d2 = parseFloat(r2.paddingLeft) + parseFloat(r2.paddingRight);
    this.containerRect = { width: l2, height: c2, innerWidth: l2 - d2, innerHeight: c2 - h2 };
    let u2 = this.option("width") || "auto", p2 = this.option("height") || "auto";
    "auto" === u2 && (u2 = parseFloat(n2.dataset.width || "") || ((t3) => {
      let e3 = 0;
      return e3 = t3 instanceof HTMLImageElement ? t3.naturalWidth : t3 instanceof SVGElement ? t3.width.baseVal.value : t3.offsetWidth, Math.max(e3, t3.scrollWidth);
    })(n2)), "auto" === p2 && (p2 = parseFloat(n2.dataset.height || "") || ((t3) => {
      let e3 = 0;
      return e3 = t3 instanceof HTMLImageElement ? t3.naturalHeight : t3 instanceof SVGElement ? t3.height.baseVal.value : t3.offsetHeight, Math.max(e3, t3.scrollHeight);
    })(n2));
    const m2 = (this.option("transformParent") ? n2.parentElement : null) || n2, f2 = m2.getAttribute("style") || "";
    m2.style.setProperty("transform", "none", "important"), n2 instanceof HTMLImageElement && (m2.style.width = "", m2.style.height = ""), m2.offsetHeight;
    const g2 = n2.getBoundingClientRect();
    let b2 = g2.width, y2 = g2.height, w2 = 0, x2 = 0;
    if (n2 instanceof HTMLImageElement && ({ width: b2, height: y2, top: w2, left: x2 } = ((t3, e3, i3, n3) => {
      const s3 = i3 / n3;
      return s3 > t3 / e3 ? (i3 = t3, n3 = t3 / s3) : (i3 = e3 * s3, n3 = e3), { width: i3, height: n3, top: 0.5 * (e3 - n3), left: 0.5 * (t3 - i3) };
    })(g2.width, g2.height, u2, p2)), this.contentRect = Object.assign(Object.assign({}, this.contentRect), { top: g2.top - a2.top + w2, bottom: a2.bottom - g2.bottom + w2, left: g2.left - a2.left + x2, right: a2.right - g2.right + x2, fitWidth: b2, fitHeight: y2, width: b2, height: y2, fullWidth: u2, fullHeight: p2 }), m2.style.cssText = f2, n2 instanceof HTMLImageElement && (m2.style.width = `${b2}px`, m2.style.height = `${y2}px`), this.setTransform(), true !== t2) {
      let t3 = "";
      Math.abs(l2 - s2) > 1 && (t3 += "x"), Math.abs(c2 - o2) > 1 && (t3 += "y"), t3 && this.emit("refresh", t3);
    }
    this.ignoreBounds || (v(this.targetScale) < v(this.minScale) ? this.zoomTo(this.minScale, { friction: 0 }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, { friction: 0 }) : this.state === T.Init || this.checkBounds().inBounds || this.requestTick()), this.updateControls();
  }
  getBounds() {
    const t2 = this.option("bounds");
    if ("auto" !== t2)
      return t2;
    const { contentWidth: e2, contentHeight: i2 } = this.calculateContentDim(this.target);
    let n2 = 0, s2 = 0, o2 = 0, a2 = 0;
    const r2 = this.option("infinite");
    if (true === r2 || this.lockedAxis && r2 === this.lockedAxis)
      n2 = -1 / 0, o2 = 1 / 0, s2 = -1 / 0, a2 = 1 / 0;
    else {
      let { containerRect: t3, contentRect: r3 } = this, l2 = v(this.contentRect.fitWidth * this.targetScale, 1e3), c2 = v(this.contentRect.fitHeight * this.targetScale, 1e3), { innerWidth: h2, innerHeight: d2 } = t3;
      if (this.containerRect.width === l2 && (h2 = t3.width), this.containerRect.width === c2 && (d2 = t3.height), e2 > h2) {
        o2 = 0.5 * (e2 - h2), n2 = -1 * o2;
        let t4 = 0.5 * (r3.right - r3.left);
        n2 += t4, o2 += t4;
      }
      if (this.contentRect.fitWidth > h2 && e2 < h2 && (n2 -= 0.5 * (this.contentRect.fitWidth - h2), o2 -= 0.5 * (this.contentRect.fitWidth - h2)), i2 > d2) {
        a2 = 0.5 * (i2 - d2), s2 = -1 * a2;
        let t4 = 0.5 * (r3.bottom - r3.top);
        s2 += t4, a2 += t4;
      }
      this.contentRect.fitHeight > d2 && i2 < d2 && (n2 -= 0.5 * (this.contentRect.fitHeight - d2), o2 -= 0.5 * (this.contentRect.fitHeight - d2));
    }
    return { x: { min: n2, max: o2 }, y: { min: s2, max: a2 } };
  }
  updateControls() {
    const t2 = this, e2 = t2.container;
    let i2 = { toggleMax: this.targetScale - this.minScale < 0.5 * (this.maxScale - this.minScale) ? this.maxScale : this.minScale, toggleCover: this.targetScale - this.minScale < 0.5 * (this.coverScale - this.minScale) ? this.coverScale : this.minScale, toggleZoom: this.targetScale - this.minScale < 0.5 * (this.fullScale - this.minScale) ? this.fullScale : this.minScale }[this.option("click") || ""] || this.minScale, n2 = t2.canZoomIn(), s2 = t2.canZoomOut(), o2 = "drag" === this.panMode, a2 = s2 && o2;
    this.targetScale <= this.minScale && !this.panOnlyZoomed && (a2 = true), (this.contentRect.width - this.contentRect.fitWidth > -1 || this.contentRect.height - this.contentRect.fitHeight > -1) && (a2 = true), this.contentRect.width * this.targetScale < this.contentRect.fitWidth && (a2 = false), "mousemove" === this.panMode && (a2 = false);
    let r2 = n2 && v(i2) > v(this.targetScale), l2 = !r2 && !a2 && s2 && v(i2) < v(this.targetScale);
    x(e2, this.cn("canZoomIn"), r2), x(e2, this.cn("canZoomOut"), l2), x(e2, this.cn("isDraggable"), a2);
    for (const t3 of e2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
      n2 ? (t3.removeAttribute("disabled"), t3.removeAttribute("tabindex")) : (t3.setAttribute("disabled", ""), t3.setAttribute("tabindex", "-1"));
    for (const t3 of e2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
      s2 ? (t3.removeAttribute("disabled"), t3.removeAttribute("tabindex")) : (t3.setAttribute("disabled", ""), t3.setAttribute("tabindex", "-1"));
    for (const i3 of e2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
      n2 = t2.targetScale < t2.fullScale - 0.1, n2 || s2 ? (i3.removeAttribute("disabled"), i3.removeAttribute("tabindex")) : (i3.setAttribute("disabled", ""), i3.setAttribute("tabindex", "-1"));
      const e3 = i3.querySelector("g");
      e3 && (e3.style.display = t2.targetScale > 0.9 * t2.fullScale ? "none" : "");
    }
  }
  panTo({ x: t2 = this.target.e, y: e2 = this.target.f, scale: i2 = this.targetScale, friction: n2 = this.option("friction"), angle: s2 = 0, originX: o2 = 0, originY: a2 = 0, flipX: r2 = false, flipY: l2 = false, ignoreBounds: c2 = false }) {
    this.state !== T.Destroy && this.applyChange({ panX: t2 - this.target.e, panY: e2 - this.target.f, scale: i2 / this.targetScale, angle: s2, originX: o2, originY: a2, friction: n2, flipX: r2, flipY: l2, ignoreBounds: c2 });
  }
  applyChange({ panX: t2 = 0, panY: e2 = 0, scale: i2 = 1, angle: n2 = 0, originX: s2 = -this.current.e, originY: o2 = -this.current.f, friction: a2 = this.option("friction"), flipX: r2 = false, flipY: l2 = false, ignoreBounds: c2 = false, bounce: h2 = this.option("bounce") }) {
    const d2 = this.state;
    if (d2 === T.Init || d2 === T.Destroy)
      return;
    this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
    for (const t3 of O)
      this.velocity[t3] = 0;
    this.friction = a2 || 0, this.ignoreBounds = c2;
    const { current: u2 } = this, p2 = u2.e, m2 = u2.f, f2 = this.getMatrix(this.target);
    let g2 = new DOMMatrix().translate(p2, m2).translate(s2, o2).translate(t2, e2);
    if (this.option("zoom")) {
      if (!c2) {
        const t3 = this.targetScale, e3 = this.minScale, n3 = this.maxScale;
        t3 * i2 < e3 && (i2 = e3 / t3), t3 * i2 > n3 && (i2 = n3 / t3);
      }
      g2 = g2.scale(i2);
    }
    g2 = g2.translate(-s2, -o2).translate(-p2, -m2).multiply(f2), n2 && (g2 = g2.rotate(n2)), r2 && (g2 = g2.scale(-1, 1)), l2 && (g2 = g2.scale(1, -1));
    for (const t3 of O)
      "a" != t3 && "d" != t3 || !(g2[t3] > this.minScale + 1e-5 || g2[t3] < this.minScale - 1e-5) ? this.target[t3] = v(g2[t3], 1e3) : this.target[t3] = g2[t3];
    (this.targetScale < this.scale || Math.abs(i2 - 1) > 0.1 || "mousemove" === this.panMode || false === h2) && !c2 && this.clampTargetBounds(), this.isResting || (this.state = T.Panning, this.requestTick());
  }
  stop(t2 = false) {
    if (this.state === T.Init || this.state === T.Destroy)
      return;
    const e2 = this.isTicking;
    this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = false, this.isBouncingY = false;
    for (const e3 of O)
      this.velocity[e3] = 0, "current" === t2 ? this.current[e3] = this.target[e3] : "target" === t2 && (this.target[e3] = this.current[e3]);
    this.setTransform(), z(this.container, "is-scaling"), z(this.container, "is-animating"), this.isTicking = false, this.state = T.Ready, e2 && (this.emit("endAnimation"), this.updateControls());
  }
  requestTick() {
    this.isTicking || (this.emit("startAnimation"), this.updateControls(), R(this.container, "is-animating"), this.isScaling && R(this.container, "is-scaling")), this.isTicking = true, this.rAF || (this.rAF = requestAnimationFrame(() => this.animate()));
  }
  panWithMouse(t2, e2 = this.option("mouseMoveFriction")) {
    if (this.prevMouseMoveEvent = t2, "mousemove" !== this.panMode || !t2)
      return;
    if (v(this.targetScale) <= v(this.minScale))
      return;
    this.emit("mouseMove", t2);
    const { container: i2, containerRect: n2, contentRect: s2 } = this, o2 = n2.width, a2 = n2.height, r2 = i2.getBoundingClientRect(), l2 = (t2.clientX || 0) - r2.left, c2 = (t2.clientY || 0) - r2.top;
    let { contentWidth: h2, contentHeight: d2 } = this.calculateContentDim(this.target);
    const u2 = this.option("mouseMoveFactor");
    u2 > 1 && (h2 !== o2 && (h2 *= u2), d2 !== a2 && (d2 *= u2));
    let p2 = 0.5 * (h2 - o2) - l2 / o2 * 100 / 100 * (h2 - o2);
    p2 += 0.5 * (s2.right - s2.left);
    let m2 = 0.5 * (d2 - a2) - c2 / a2 * 100 / 100 * (d2 - a2);
    m2 += 0.5 * (s2.bottom - s2.top), this.applyChange({ panX: p2 - this.target.e, panY: m2 - this.target.f, friction: e2 });
  }
  zoomWithWheel(t2) {
    if (this.state === T.Destroy || this.state === T.Init)
      return;
    const e2 = Math.abs(t2.deltaY) < 100 && Math.abs(t2.deltaX) < 100 ? 25 : 50, i2 = Math.max(-1, Math.min(1, -t2.deltaY || -t2.deltaX || -t2.detail)), n2 = this.targetScale, s2 = this.maxScale, o2 = this.minScale;
    let a2 = n2 * (100 + i2 * e2) / 100;
    a2 < o2 && n2 <= o2 ? (this.wheelDelta += Math.abs(i2), a2 = o2) : a2 > s2 && n2 >= s2 ? (this.wheelDelta += Math.abs(i2), a2 = s2) : (this.wheelDelta = 0, a2 = Math.max(Math.min(a2, s2), o2)), this.wheelDelta > this.option("wheelLimit") || (t2.preventDefault(), a2 !== n2 && this.zoomTo(a2, { event: t2 }));
  }
  canZoomIn() {
    return this.option("zoom") && (this.contentRect.width < this.contentRect.fitWidth || this.targetScale < this.maxScale - 1e-5);
  }
  canZoomOut() {
    return this.option("zoom") && this.targetScale > this.minScale + 1e-5;
  }
  zoomIn(t2 = 1.25, e2) {
    this.zoomTo(this.targetScale * t2, e2);
  }
  zoomOut(t2 = 0.8, e2) {
    this.zoomTo(this.targetScale * t2, e2);
  }
  zoomToFit(t2) {
    this.zoomTo("fit", t2);
  }
  zoomToCover(t2) {
    this.zoomTo("cover", t2);
  }
  zoomToFull(t2) {
    this.zoomTo("full", t2);
  }
  zoomToMax(t2) {
    this.zoomTo("max", t2);
  }
  toggleZoom(t2) {
    this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.fullScale - this.minScale) ? "full" : "fit", t2);
  }
  toggleMax(t2) {
    this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.maxScale - this.minScale) ? "max" : "fit", t2);
  }
  toggleCover(t2) {
    this.zoomTo(this.targetScale - this.minScale < 0.5 * (this.coverScale - this.minScale) ? "cover" : "fit", t2);
  }
  iterateZoom(t2) {
    this.zoomTo("next", t2);
  }
  zoomTo(t2 = 1, { friction: e2 = "auto", originX: i2 = 0, originY: n2 = 0, event: s2 } = {}) {
    if (this.isContentLoading || this.state === T.Destroy)
      return;
    this.stop();
    const { targetScale: o2 } = this;
    let a2 = 1;
    if ("mousemove" === this.panMode && (s2 = this.prevMouseMoveEvent || s2), s2) {
      const t3 = this.content.getBoundingClientRect(), e3 = s2.clientX || 0, o3 = s2.clientY || 0;
      i2 = e3 - t3.left - 0.5 * t3.width, n2 = o3 - t3.top - 0.5 * t3.height;
    }
    const r2 = this.fullScale, l2 = this.maxScale;
    let c2 = this.coverScale;
    "number" == typeof t2 ? a2 = t2 / o2 : ("next" === t2 && (r2 - c2 < 0.2 && (c2 = r2), t2 = o2 < r2 - 1e-5 ? "full" : o2 < l2 - 1e-5 ? "max" : "fit"), a2 = "full" === t2 ? r2 / o2 || 1 : "cover" === t2 ? c2 / o2 || 1 : "max" === t2 ? l2 / o2 || 1 : 1 / o2 || 1), e2 = "auto" === e2 ? a2 > 1 ? 0.15 : 0.25 : e2, this.applyChange({ scale: a2, originX: i2, originY: n2, friction: e2 }), s2 && "mousemove" === this.panMode && this.panWithMouse(s2, e2);
  }
  rotateCCW() {
    this.applyChange({ angle: -90 });
  }
  rotateCW() {
    this.applyChange({ angle: 90 });
  }
  flipX() {
    this.applyChange({ flipX: true });
  }
  flipY() {
    this.applyChange({ flipY: true });
  }
  fitX() {
    this.stop("target");
    const { containerRect: t2, contentRect: e2, target: i2 } = this;
    this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.height - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.width / e2.fitWidth / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
  }
  fitY() {
    this.stop("target");
    const { containerRect: t2, contentRect: e2, target: i2 } = this;
    this.applyChange({ panX: 0.5 * t2.width - (e2.left + 0.5 * e2.fitWidth) - i2.e, panY: 0.5 * t2.height - (e2.top + 0.5 * e2.fitHeight) - i2.f, scale: t2.height / e2.fitHeight / this.targetScale, originX: 0, originY: 0, ignoreBounds: true });
  }
  toggleFS() {
    const { container: t2 } = this, e2 = this.cn("inFullscreen"), i2 = this.cn("htmlHasFullscreen");
    t2.classList.toggle(e2);
    const n2 = t2.classList.contains(e2);
    n2 ? (document.documentElement.classList.add(i2), document.addEventListener("keydown", this.onKeydown, true)) : (document.documentElement.classList.remove(i2), document.removeEventListener("keydown", this.onKeydown, true)), this.updateMetrics(), this.emit(n2 ? "enterFS" : "exitFS");
  }
  getMatrix(t2 = this.current) {
    const { a: e2, b: i2, c: n2, d: s2, e: o2, f: a2 } = t2;
    return new DOMMatrix([e2, i2, n2, s2, o2, a2]);
  }
  reset(t2) {
    if (this.state !== T.Init && this.state !== T.Destroy) {
      this.stop("current");
      for (const t3 of O)
        this.target[t3] = k[t3];
      this.target.a = this.minScale, this.target.d = this.minScale, this.isResting || (this.friction = void 0 === t2 ? this.option("friction") : t2, this.state = T.Panning, this.requestTick());
    }
  }
  destroy() {
    this.stop(), this.state = T.Destroy, this.detachEvents(), this.detachObserver();
    const { container: t2, content: e2 } = this, i2 = this.option("classes") || {};
    for (const e3 of Object.values(i2))
      t2.classList.remove(e3 + "");
    e2 && (e2.removeEventListener("load", this.onLoad), e2.removeEventListener("error", this.onError)), this.detachPlugins();
  }
};
Object.defineProperty(F, "defaults", { enumerable: true, configurable: true, writable: true, value: A }), Object.defineProperty(F, "Plugins", { enumerable: true, configurable: true, writable: true, value: {} });
var j = (t2) => new Promise((e2, i2) => {
  const n2 = new Image();
  n2.onload = e2, n2.onerror = i2, n2.src = t2;
});
var H = class extends m {
  onCreateSlide(t2, e2, i2) {
    const n2 = this.instance, s2 = n2.optionFor(i2, "src") || "", { el: o2, type: a2 } = i2;
    o2 && "image" === a2 && "string" == typeof s2 && this.setContent(i2, s2).then((t3) => {
      if (n2.isClosing())
        return;
      const e3 = i2.contentEl, s3 = i2.imageEl, o3 = i2.thumbElSrc, a3 = this.optionFor(i2, "initialSize"), r2 = this.optionFor(i2, "zoom"), l2 = { event: n2.prevMouseMoveEvent || n2.options.event, friction: r2 ? 0.12 : 0 };
      if (e3 && s3 && o3 && n2.isOpeningSlide(i2) && this.getZoomInfo(i2)) {
        let t4 = document.createElement("img");
        R(t4, "fancybox-ghost"), e3.appendChild(t4), t4.src = o3, setTimeout(() => {
          n2.animate(t4, "f-fadeFastOut", () => {
            t4 && (t4.remove(), t4 = null);
          });
        }, 333), j(o3).then(() => {
          i2.state = h.Opening, this.instance.emit("reveal", i2), this.zoomIn(i2).then(() => {
            this.instance.done(i2);
          }, () => {
            n2.hideLoading(i2);
          });
        }, () => {
          n2.hideLoading(i2), n2.revealContent(i2);
        });
      } else {
        let e4 = n2.optionFor(i2, "showClass") || void 0, s4 = true;
        n2.isOpeningSlide(i2) && ("full" === a3 ? t3.zoomToFull(l2) : "cover" === a3 ? t3.zoomToCover(l2) : "max" === a3 ? t3.zoomToMax(l2) : s4 = false, t3.stop("current")), s4 && e4 && (e4 = "f-fadeIn"), n2.revealContent(i2, e4);
      }
    }, () => {
      n2.setError(i2, "{{IMAGE_ERROR}}");
    });
  }
  onRemoveSlide(t2, e2, i2) {
    i2.panzoom && i2.panzoom.destroy(), i2.panzoom = void 0, i2.imageEl = void 0;
  }
  onChange(t2, e2, i2, n2) {
    for (const t3 of e2.slides) {
      const e3 = t3.panzoom;
      e3 && t3.index !== i2 && e3.reset(0.35);
    }
  }
  onClose() {
    const t2 = this.instance, e2 = t2.container, i2 = t2.getSlide();
    if (!e2 || !e2.parentElement || !i2)
      return;
    const { el: n2, contentEl: s2, panzoom: o2 } = i2, a2 = i2.thumbElSrc;
    if (!n2 || !a2 || !s2 || !o2 || o2.isContentLoading || o2.state === T.Init || o2.state === T.Destroy)
      return;
    o2.updateMetrics();
    let r2 = this.getZoomInfo(i2);
    if (!r2)
      return;
    this.instance.state = c.CustomClosing, n2.classList.remove("is-zooming-in"), n2.classList.add("is-zooming-out"), s2.style.backgroundImage = `url('${a2}')`, j(a2).then(() => {
      n2.classList.add("hide-image");
    }, () => {
    });
    const l2 = e2.getBoundingClientRect();
    Object.assign(e2.style, { position: "absolute", top: `${window.pageYOffset}px`, left: `${window.pageXOffset}px`, bottom: "auto", right: "auto", width: `${l2.width}px`, height: `${l2.height}px`, overflow: "hidden" });
    const { x: h2, y: d2, scale: u2, opacity: p2 } = r2;
    if (p2) {
      const t3 = ((t4, e3, i3, n3) => {
        const s3 = e3 - t4, o3 = n3 - i3;
        return (e4) => i3 + ((e4 - t4) / s3 * o3 || 0);
      })(o2.scale, u2, 1, 0);
      o2.on("afterTransform", () => {
        s2.style.opacity = t3(o2.scale) + "";
      });
    }
    o2.on("endAnimation", () => {
      t2.destroy();
    }), o2.target.a = u2, o2.target.b = 0, o2.target.c = 0, o2.target.d = u2, o2.panTo({ x: h2, y: d2, scale: u2, friction: p2 ? 0.2 : 0.33, ignoreBounds: true }), o2.isResting && t2.destroy();
  }
  setContent(t2, i2) {
    return new Promise((n2, s2) => {
      var o2, a2;
      const r2 = this.instance, l2 = t2.el;
      if (!l2)
        return void s2();
      r2.showLoading(t2);
      const c2 = document.createElement("img");
      if (c2.classList.add("fancybox-image"), c2.src = i2 || "", c2.alt = (null === (o2 = t2.caption) || void 0 === o2 ? void 0 : o2.replace(/<[^>]+>/gi, "").substring(0, 1e3)) || `Image ${t2.index + 1} of ${null === (a2 = r2.carousel) || void 0 === a2 ? void 0 : a2.pages.length}`, c2.draggable = false, t2.srcset && c2.setAttribute("srcset", t2.srcset), t2.sizes && c2.setAttribute("sizes", t2.sizes), t2.imageEl = c2, r2.setContent(t2, c2, false), this.option("protected")) {
        l2.addEventListener("contextmenu", (t3) => {
          t3.preventDefault();
        });
        const e2 = t2.contentEl;
        if (e2) {
          const t3 = document.createElement("div");
          R(t3, "fancybox-protected"), e2.append(t3);
        }
      }
      t2.panzoom = new F(l2, e({}, this.option("Panzoom") || {}, { content: c2, width: r2.optionFor(t2, "width", "auto"), height: r2.optionFor(t2, "height", "auto"), wheel: () => {
        const t3 = r2.option("wheel");
        return ("zoom" === t3 || "pan" == t3) && t3;
      }, click: (e2, i3) => {
        var n3;
        if (r2.isCompact || r2.isClosing())
          return false;
        let s3 = !i3 || i3.target && (null === (n3 = t2.contentEl) || void 0 === n3 ? void 0 : n3.contains(i3.target));
        return r2.option(s3 ? "contentClick" : "backdropClick") || false;
      }, dblClick: () => r2.isCompact ? "toggleZoom" : r2.option("contentDblClick") || false, spinner: false, panOnlyZoomed: true, wheelLimit: 1 / 0, transformParent: true, on: { ready: (t3) => {
        n2(t3);
      }, error: () => {
        s2();
      }, destroy: () => {
        s2();
      } } }));
    });
  }
  zoomIn(t2) {
    return new Promise((e2, i2) => {
      const { panzoom: n2, contentEl: s2, el: o2 } = t2;
      n2 && n2.updateMetrics();
      const a2 = this.getZoomInfo(t2);
      if (!(a2 && o2 && s2 && n2))
        return void i2();
      const { x: r2, y: l2, scale: c2, opacity: d2 } = a2, u2 = () => {
        t2.state !== h.Closing && (d2 && (s2.style.opacity = Math.max(Math.min(1, 1 - (1 - n2.scale) / (1 - c2)), 0) + ""), n2.scale >= 1 && n2.scale > n2.targetScale - 0.1 && e2(n2));
      }, p2 = (t3) => {
        t3.scale < 0.99 || t3.scale > 1.01 || (s2.style.opacity = "", o2.classList.remove("is-zooming-in"), t3.off("endAnimation", p2), t3.off("touchStart", p2), t3.off("afterTransform", u2), e2(t3));
      };
      n2.on("endAnimation", p2), n2.on("touchStart", p2), n2.on("afterTransform", u2), n2.on(["error", "destroy"], () => {
        i2();
      }), n2.panTo({ x: r2, y: l2, scale: c2, friction: 0, ignoreBounds: true }), n2.stop("current");
      const m2 = this.instance, f2 = { event: "mousemove" === n2.panMode ? m2.prevMouseMoveEvent || m2.options.event : void 0 }, g2 = this.optionFor(t2, "initialSize");
      R(o2, "is-zooming-in"), m2.hideLoading(t2), "full" === g2 ? n2.zoomToFull(f2) : "cover" === g2 ? n2.zoomToCover(f2) : "max" === g2 ? n2.zoomToMax(f2) : n2.reset(0.165);
    });
  }
  getZoomInfo(t2) {
    const { el: e2, imageEl: i2, thumbEl: n2, panzoom: s2 } = t2;
    if (!e2 || !i2 || !n2 || !s2 || ((t3) => {
      const e3 = window.pageYOffset, i3 = window.pageYOffset + window.innerHeight;
      if (!L(t3))
        return 0;
      const n3 = t3.getBoundingClientRect(), s3 = n3.y + window.pageYOffset, o3 = n3.y + n3.height + window.pageYOffset;
      if (e3 > o3 || i3 < s3)
        return 0;
      if (e3 < s3 && i3 > o3)
        return 100;
      if (s3 < e3 && o3 > i3)
        return 100;
      let a3 = n3.height;
      s3 < e3 && (a3 -= window.pageYOffset - s3), o3 > i3 && (a3 -= o3 - i3);
      const r3 = a3 / window.innerHeight * 100;
      return Math.round(r3);
    })(n2) < 5 || !this.optionFor(t2, "zoom") || this.instance.state === c.Destroy)
      return false;
    const { top: o2, left: a2, width: r2, height: l2 } = n2.getBoundingClientRect();
    let { top: h2, left: d2, fitWidth: u2, fitHeight: p2 } = s2.contentRect;
    if (!(r2 && l2 && u2 && p2))
      return false;
    const m2 = r2 / u2, f2 = s2.container.getBoundingClientRect();
    h2 += f2.top, d2 += f2.left;
    const g2 = -1 * (d2 + 0.5 * u2 - (a2 + 0.5 * r2)), b2 = -1 * (h2 + 0.5 * p2 - (o2 + 0.5 * l2));
    let v2 = this.option("zoomOpacity") || false;
    return "auto" === v2 && (v2 = Math.abs(r2 / l2 - u2 / p2) > 0.1), { x: g2, y: b2, scale: m2, opacity: v2 };
  }
  attach() {
    this.instance.on("Carousel.change", this.onChange), this.instance.on("Carousel.createSlide", this.onCreateSlide), this.instance.on("Carousel.removeSlide", this.onRemoveSlide), this.instance.on("close", this.onClose);
  }
  detach() {
    this.instance.off("Carousel.change", this.onChange), this.instance.off("Carousel.createSlide", this.onCreateSlide), this.instance.off("Carousel.removeSlide", this.onRemoveSlide), this.instance.off("close", this.onClose);
  }
};
Object.defineProperty(H, "defaults", { enumerable: true, configurable: true, writable: true, value: { initialSize: "fit", Panzoom: { maxScale: 1 }, protected: false, zoom: true, zoomOpacity: "auto" } });
var B = (t2, e2 = {}) => {
  const i2 = new URL(t2), n2 = new URLSearchParams(i2.search), s2 = new URLSearchParams();
  for (const [t3, i3] of [...n2, ...Object.entries(e2)]) {
    let e3 = i3.toString();
    "t" === t3 ? s2.set("start", parseInt(e3).toString()) : s2.set(t3, e3);
  }
  let o2 = s2.toString(), a2 = t2.match(/#t=((.*)?\d+s)/);
  return a2 && (o2 += `#t=${a2[1]}`), o2;
};
var _ = { ajax: null, autoSize: true, preload: true, videoAutoplay: true, videoRatio: 16 / 9, videoTpl: `<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">
  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn't support embedded videos.</video>`, videoFormat: "", vimeo: { byline: 1, color: "00adef", controls: 1, dnt: 1, muted: 0 }, youtube: { controls: 1, enablejsapi: 1, rel: 0, fs: 1 } };
var N = ["image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo", "video"];
var W = class extends m {
  onInitSlide(t2, e2, i2) {
    this.processType(i2);
  }
  onCreateSlide(t2, e2, i2) {
    this.setContent(i2);
  }
  onRemoveSlide(t2, e2, i2) {
    i2.closeBtnEl && (i2.closeBtnEl.remove(), i2.closeBtnEl = void 0), i2.xhr && (i2.xhr.abort(), i2.xhr = null), i2.iframeEl && (i2.iframeEl.onload = i2.iframeEl.onerror = null, i2.iframeEl.src = "//about:blank", i2.iframeEl = null);
    const n2 = i2.contentEl, s2 = i2.placeholderEl;
    if ("inline" === i2.type && n2 && s2)
      n2.classList.remove("fancybox__content"), "none" !== n2.style.display && (n2.style.display = "none"), s2.parentNode && s2.parentNode.insertBefore(n2, s2), s2.remove(), i2.placeholderEl = null;
    else
      for (; i2.el && i2.el.firstChild; )
        i2.el.removeChild(i2.el.firstChild);
  }
  onSelectSlide(t2, e2, i2) {
    i2.state === h.Ready && this.playVideo();
  }
  onUnselectSlide(t2, e2, i2) {
    var n2, s2;
    if ("html5video" === i2.type) {
      try {
        null === (s2 = null === (n2 = i2.el) || void 0 === n2 ? void 0 : n2.querySelector("video")) || void 0 === s2 || s2.pause();
      } catch (t3) {
      }
      return;
    }
    let o2;
    "vimeo" === i2.type ? o2 = { method: "pause", value: "true" } : "youtube" === i2.type && (o2 = { event: "command", func: "pauseVideo" }), o2 && i2.iframeEl && i2.iframeEl.contentWindow && i2.iframeEl.contentWindow.postMessage(JSON.stringify(o2), "*"), i2.poller && clearTimeout(i2.poller);
  }
  onDone(t2, e2) {
    t2.isCurrentSlide(e2) && !t2.isClosing() && this.playVideo();
  }
  onRefresh(t2, e2) {
    e2.slides.forEach((t3) => {
      t3.el && (this.setAspectRatio(t3), this.resizeIframe(t3));
    });
  }
  onMessage(t2) {
    try {
      let e2 = JSON.parse(t2.data);
      if ("https://player.vimeo.com" === t2.origin) {
        if ("ready" === e2.event)
          for (let e3 of Array.from(document.getElementsByClassName("fancybox__iframe")))
            e3 instanceof HTMLIFrameElement && e3.contentWindow === t2.source && (e3.dataset.ready = "true");
      } else if ("https://www.youtube-nocookie.com" === t2.origin && "onReady" === e2.event) {
        const t3 = document.getElementById(e2.id);
        t3 && (t3.dataset.ready = "true");
      }
    } catch (t3) {
    }
  }
  loadAjaxContent(t2) {
    const e2 = this.instance.optionFor(t2, "src") || "";
    this.instance.showLoading(t2);
    const i2 = this.instance, n2 = new XMLHttpRequest();
    i2.showLoading(t2), n2.onreadystatechange = function() {
      n2.readyState === XMLHttpRequest.DONE && i2.state === c.Ready && (i2.hideLoading(t2), 200 === n2.status ? i2.setContent(t2, n2.responseText) : i2.setError(t2, 404 === n2.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
    };
    const s2 = t2.ajax || null;
    n2.open(s2 ? "POST" : "GET", e2 + ""), n2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), n2.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n2.send(s2), t2.xhr = n2;
  }
  setInlineContent(t2) {
    let e2 = null;
    if (L(t2.src))
      e2 = t2.src;
    else if ("string" == typeof t2.src) {
      const i2 = t2.src.split("#", 2).pop();
      e2 = i2 ? document.getElementById(i2) : null;
    }
    if (e2) {
      if ("clone" === t2.type || e2.dataset.placeholderId) {
        e2 = e2.cloneNode(true);
        const i2 = e2.dataset.animationName;
        i2 && (e2.classList.remove(i2), delete e2.dataset.animationName), delete e2.dataset.placeholderId;
        let n2 = e2.getAttribute("id");
        n2 = n2 ? `${n2}--clone` : `clone-${this.instance.id}-${t2.index}`, e2.setAttribute("id", n2);
      } else if (e2.parentNode) {
        const i2 = document.createElement("div");
        i2.classList.add("fancybox-placeholder"), e2.parentNode.insertBefore(i2, e2), t2.placeholderEl = i2;
      }
      this.instance.setContent(t2, e2);
    } else
      this.instance.setError(t2, "{{ELEMENT_NOT_FOUND}}");
  }
  setIframeContent(t2) {
    const { src: e2, el: i2 } = t2;
    if (!e2 || "string" != typeof e2 || !i2)
      return;
    const n2 = this.instance, s2 = document.createElement("iframe");
    s2.className = "fancybox__iframe", s2.setAttribute("id", `fancybox__iframe_${n2.id}_${t2.index}`), s2.setAttribute("allow", "autoplay; fullscreen"), s2.setAttribute("scrolling", "auto"), s2.onerror = () => {
      n2.setError(t2, "{{IFRAME_ERROR}}");
    }, t2.iframeEl = s2;
    const o2 = this.optionFor(t2, "preload");
    if (i2.classList.add("is-loading"), "iframe" !== t2.type || false === o2)
      return s2.setAttribute("src", t2.src + ""), this.resizeIframe(t2), void n2.setContent(t2, s2);
    n2.showLoading(t2), s2.onload = () => {
      if (!s2.src.length)
        return;
      const e3 = "true" !== s2.dataset.ready;
      s2.dataset.ready = "true", this.resizeIframe(t2), e3 ? n2.revealContent(t2) : n2.hideLoading(t2);
    }, s2.setAttribute("src", e2), n2.setContent(t2, s2, false);
  }
  resizeIframe(t2) {
    const e2 = t2.iframeEl, i2 = null == e2 ? void 0 : e2.parentElement;
    if (!e2 || !i2)
      return;
    let n2 = t2.autoSize, s2 = t2.width || 0, o2 = t2.height || 0;
    s2 && o2 && (n2 = false);
    const a2 = i2 && i2.style;
    if (false !== t2.preload && false !== n2 && a2)
      try {
        const t3 = window.getComputedStyle(i2), n3 = parseFloat(t3.paddingLeft) + parseFloat(t3.paddingRight), r2 = parseFloat(t3.paddingTop) + parseFloat(t3.paddingBottom), l2 = e2.contentWindow;
        if (l2) {
          const t4 = l2.document, e3 = t4.getElementsByTagName("html")[0], i3 = t4.body;
          a2.width = "", i3.style.overflow = "hidden", s2 = s2 || e3.scrollWidth + n3, a2.width = `${s2}px`, i3.style.overflow = "", a2.flex = "0 0 auto", a2.height = `${i3.scrollHeight}px`, o2 = e3.scrollHeight + r2;
        }
      } catch (t3) {
      }
    if (s2 || o2) {
      const t3 = { flex: "0 1 auto", width: "", height: "" };
      s2 && (t3.width = `${s2}px`), o2 && (t3.height = `${o2}px`), Object.assign(a2, t3);
    }
  }
  playVideo() {
    const t2 = this.instance.getSlide();
    if (!t2)
      return;
    const { el: e2 } = t2;
    if (!e2 || !e2.offsetParent)
      return;
    if (!this.optionFor(t2, "videoAutoplay"))
      return;
    if ("html5video" === t2.type)
      try {
        const t3 = e2.querySelector("video");
        if (t3) {
          const e3 = t3.play();
          void 0 !== e3 && e3.then(() => {
          }).catch((e4) => {
            t3.muted = true, t3.play();
          });
        }
      } catch (t3) {
      }
    if ("youtube" !== t2.type && "vimeo" !== t2.type)
      return;
    const i2 = () => {
      if (t2.iframeEl && t2.iframeEl.contentWindow) {
        let e3;
        if ("true" === t2.iframeEl.dataset.ready)
          return e3 = "youtube" === t2.type ? { event: "command", func: "playVideo" } : { method: "play", value: "true" }, e3 && t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"), void (t2.poller = void 0);
        "youtube" === t2.type && (e3 = { event: "listening", id: t2.iframeEl.getAttribute("id") }, t2.iframeEl.contentWindow.postMessage(JSON.stringify(e3), "*"));
      }
      t2.poller = setTimeout(i2, 250);
    };
    i2();
  }
  processType(t2) {
    if (t2.html)
      return t2.type = "html", t2.src = t2.html, void (t2.html = "");
    const e2 = this.instance.optionFor(t2, "src", "");
    if (!e2 || "string" != typeof e2)
      return;
    let i2 = t2.type, n2 = null;
    if (n2 = e2.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
      const s2 = B(e2, this.optionFor(t2, "youtube")), o2 = encodeURIComponent(n2[1]);
      t2.videoId = o2, t2.src = `https://www.youtube-nocookie.com/embed/${o2}?${s2}`, t2.thumbSrc = t2.thumbSrc || `https://i.ytimg.com/vi/${o2}/mqdefault.jpg`, i2 = "youtube";
    } else if (n2 = e2.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) {
      const s2 = B(e2, this.optionFor(t2, "vimeo")), o2 = encodeURIComponent(n2[1]);
      t2.videoId = o2, t2.src = `https://player.vimeo.com/video/${o2}?${s2}`, i2 = "vimeo";
    }
    if (!i2 && t2.triggerEl) {
      const e3 = t2.triggerEl.dataset.type;
      N.includes(e3) && (i2 = e3);
    }
    i2 || "string" == typeof e2 && ("#" === e2.charAt(0) ? i2 = "inline" : (n2 = e2.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i2 = "html5video", t2.videoFormat = t2.videoFormat || "video/" + ("ogv" === n2[1] ? "ogg" : n2[1])) : e2.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i2 = "image" : e2.match(/\.(pdf)((\?|#).*)?$/i) ? i2 = "pdf" : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t2.src = `https://maps.google.${n2[1]}/?ll=${(n2[2] ? n2[2] + "&z=" + Math.floor(parseFloat(n2[3])) + (n2[4] ? n2[4].replace(/^\//, "&") : "") : n2[4] + "").replace(/\?/, "&")}&output=${n2[4] && n2[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, i2 = "map") : (n2 = e2.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t2.src = `https://maps.google.${n2[1]}/maps?q=${n2[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, i2 = "map")), i2 = i2 || this.instance.option("defaultType"), t2.type = i2, "image" === i2 && (t2.thumbSrc = t2.thumbSrc || t2.src);
  }
  setContent(t2) {
    const e2 = this.instance.optionFor(t2, "src") || "";
    if (t2 && t2.type && e2) {
      switch (t2.type) {
        case "html":
          this.instance.setContent(t2, e2);
          break;
        case "html5video":
          const i2 = this.option("videoTpl");
          i2 && this.instance.setContent(t2, i2.replace(/\{\{src\}\}/gi, e2 + "").replace(/\{\{format\}\}/gi, this.optionFor(t2, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t2.poster || t2.thumbSrc || ""));
          break;
        case "inline":
        case "clone":
          this.setInlineContent(t2);
          break;
        case "ajax":
          this.loadAjaxContent(t2);
          break;
        case "pdf":
        case "map":
        case "youtube":
        case "vimeo":
          t2.preload = false;
        case "iframe":
          this.setIframeContent(t2);
      }
      this.setAspectRatio(t2);
    }
  }
  setAspectRatio(t2) {
    var e2;
    const i2 = t2.contentEl, n2 = this.optionFor(t2, "videoRatio"), s2 = null === (e2 = t2.el) || void 0 === e2 ? void 0 : e2.getBoundingClientRect();
    if (!(i2 && s2 && n2 && 1 !== n2 && t2.type && ["video", "youtube", "vimeo", "html5video"].includes(t2.type)))
      return;
    const o2 = s2.width, a2 = s2.height;
    i2.style.aspectRatio = n2 + "", i2.style.width = o2 / a2 > n2 ? "auto" : "", i2.style.height = o2 / a2 > n2 ? "" : "auto";
  }
  attach() {
    this.instance.on("Carousel.initSlide", this.onInitSlide), this.instance.on("Carousel.createSlide", this.onCreateSlide), this.instance.on("Carousel.removeSlide", this.onRemoveSlide), this.instance.on("Carousel.selectSlide", this.onSelectSlide), this.instance.on("Carousel.unselectSlide", this.onUnselectSlide), this.instance.on("Carousel.Panzoom.refresh", this.onRefresh), this.instance.on("done", this.onDone), window.addEventListener("message", this.onMessage);
  }
  detach() {
    this.instance.off("Carousel.initSlide", this.onInitSlide), this.instance.off("Carousel.createSlide", this.onCreateSlide), this.instance.off("Carousel.removeSlide", this.onRemoveSlide), this.instance.off("Carousel.selectSlide", this.onSelectSlide), this.instance.off("Carousel.unselectSlide", this.onUnselectSlide), this.instance.off("Carousel.Panzoom.refresh", this.onRefresh), this.instance.off("done", this.onDone), window.removeEventListener("message", this.onMessage);
  }
};
Object.defineProperty(W, "defaults", { enumerable: true, configurable: true, writable: true, value: _ });
var $ = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: "ready" }), Object.defineProperty(this, "inHover", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "timer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "progressBar", { enumerable: true, configurable: true, writable: true, value: null });
  }
  get isActive() {
    return "ready" !== this.state;
  }
  onReady(t2) {
    this.option("autoStart") && (t2.isInfinite || t2.page < t2.pages.length - 1) && this.start();
  }
  onChange() {
    var t2;
    (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) || (this.removeProgressBar(), this.pause());
  }
  onSettle() {
    this.resume();
  }
  onVisibilityChange() {
    "visible" === document.visibilityState ? this.resume() : this.pause();
  }
  onMouseEnter() {
    this.inHover = true, this.pause();
  }
  onMouseLeave() {
    var t2;
    this.inHover = false, (null === (t2 = this.instance.panzoom) || void 0 === t2 ? void 0 : t2.isResting) && this.resume();
  }
  onTimerEnd() {
    "play" === this.state && (this.instance.isInfinite || this.instance.page !== this.instance.pages.length - 1 ? this.instance.slideNext() : this.instance.slideTo(0));
  }
  removeProgressBar() {
    this.progressBar && (this.progressBar.remove(), this.progressBar = null);
  }
  createProgressBar() {
    var t2;
    if (!this.option("showProgress"))
      return null;
    this.removeProgressBar();
    const e2 = this.instance, i2 = (null === (t2 = e2.pages[e2.page]) || void 0 === t2 ? void 0 : t2.slides) || [];
    let n2 = this.option("progressParentEl");
    if (n2 || (n2 = (1 === i2.length ? i2[0].el : null) || e2.viewport), !n2)
      return null;
    const s2 = document.createElement("div");
    return R(s2, "f-progress"), n2.prepend(s2), this.progressBar = s2, s2.offsetHeight, s2;
  }
  set() {
    if (this.instance.pages.length < 2)
      return;
    if (this.progressBar)
      return;
    const t2 = this.option("timeout");
    this.state = "play", R(this.instance.container, "has-autoplay");
    let e2 = this.createProgressBar();
    e2 && (e2.style.transitionDuration = `${t2}ms`, e2.style.transform = "scaleX(1)"), this.timer = setTimeout(() => {
      this.timer = null, this.inHover || this.onTimerEnd();
    }, t2), this.emit("set");
  }
  clear() {
    this.timer && (clearTimeout(this.timer), this.timer = null), this.removeProgressBar();
  }
  start() {
    if (this.set(), this.option("pauseOnHover")) {
      const t2 = this.instance.container;
      t2.addEventListener("mouseenter", this.onMouseEnter, false), t2.addEventListener("mouseleave", this.onMouseLeave, false);
    }
    document.addEventListener("visibilitychange", this.onVisibilityChange, false);
  }
  stop() {
    const t2 = this.instance.container;
    this.clear(), this.state = "ready", t2.removeEventListener("mouseenter", this.onMouseEnter, false), t2.removeEventListener("mouseleave", this.onMouseLeave, false), document.removeEventListener("visibilitychange", this.onVisibilityChange, false), z(t2, "has-autoplay"), this.emit("stop");
  }
  pause() {
    "play" === this.state && (this.state = "pause", this.clear(), this.emit("pause"));
  }
  resume() {
    const t2 = this.instance;
    if (t2.isInfinite || t2.page !== t2.pages.length - 1)
      if ("play" !== this.state) {
        if ("pause" === this.state && !this.inHover) {
          const t3 = new Event("resume", { bubbles: true, cancelable: true });
          this.emit("resume", event), t3.defaultPrevented || this.set();
        }
      } else
        this.set();
    else
      this.stop();
  }
  toggle() {
    "play" === this.state || "pause" === this.state ? this.stop() : this.set();
  }
  attach() {
    this.instance.on("ready", this.onReady), this.instance.on("Panzoom.startAnimation", this.onChange), this.instance.on("Panzoom.endAnimation", this.onSettle), this.instance.on("Panzoom.touchMove", this.onChange);
  }
  detach() {
    this.instance.off("ready", this.onReady), this.instance.off("Panzoom.startAnimation", this.onChange), this.instance.off("Panzoom.endAnimation", this.onSettle), this.instance.off("Panzoom.touchMove", this.onChange), this.stop();
  }
};
Object.defineProperty($, "defaults", { enumerable: true, configurable: true, writable: true, value: { autoStart: true, pauseOnHover: true, progressParentEl: null, showProgress: true, timeout: 3e3 } });
var X = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null });
  }
  onPrepare(t2) {
    const i2 = t2.carousel;
    if (!i2)
      return;
    const n2 = t2.container;
    n2 && (i2.options.Autoplay = e(this.option("Autoplay") || {}, { pauseOnHover: false, autoStart: false, timeout: this.option("timeout"), progressParentEl: () => n2.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]") || n2, on: { set: (e2) => {
      var i3;
      n2.classList.add("has-slideshow"), (null === (i3 = t2.getSlide()) || void 0 === i3 ? void 0 : i3.state) !== h.Ready && e2.pause();
    }, stop: () => {
      n2.classList.remove("has-slideshow"), t2.isCompact || t2.endIdle();
    }, resume: (e2, i3) => {
      var n3, s2, o2;
      !i3 || !i3.cancelable || (null === (n3 = t2.getSlide()) || void 0 === n3 ? void 0 : n3.state) === h.Ready && (null === (o2 = null === (s2 = t2.carousel) || void 0 === s2 ? void 0 : s2.panzoom) || void 0 === o2 ? void 0 : o2.isResting) || i3.preventDefault();
    } } }), i2.attachPlugins({ Autoplay: $ }), this.ref = i2.plugins.Autoplay);
  }
  onReady(t2) {
    const e2 = t2.carousel, i2 = this.ref;
    e2 && i2 && this.option("playOnStart") && (e2.isInfinite || e2.page < e2.pages.length - 1) && i2.start();
  }
  onDone(t2, e2) {
    const i2 = this.ref;
    if (!i2)
      return;
    const n2 = e2.panzoom;
    n2 && n2.on("startAnimation", () => {
      t2.isCurrentSlide(e2) && i2.stop();
    }), t2.isCurrentSlide(e2) && i2.resume();
  }
  onKeydown(t2, e2) {
    var i2;
    const n2 = this.ref;
    n2 && e2 === this.option("key") && "BUTTON" !== (null === (i2 = document.activeElement) || void 0 === i2 ? void 0 : i2.nodeName) && n2.toggle();
  }
  attach() {
    this.instance.on("Carousel.init", this.onPrepare), this.instance.on("Carousel.ready", this.onReady), this.instance.on("done", this.onDone), this.instance.on("keydown", this.onKeydown);
  }
  detach() {
    this.instance.off("Carousel.init", this.onPrepare), this.instance.off("Carousel.ready", this.onReady), this.instance.off("done", this.onDone), this.instance.off("keydown", this.onKeydown);
  }
};
Object.defineProperty(X, "defaults", { enumerable: true, configurable: true, writable: true, value: { key: " ", playOnStart: false, timeout: 3e3 } });
var Y = { classes: { container: "f-thumbs f-carousel__thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide", isResting: "is-resting", isSelected: "is-selected", isLoading: "is-loading", hasThumbs: "has-thumbs" }, minCount: 2, parentEl: null, thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>', type: "modern" };
var q;
!function(t2) {
  t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Hidden = 2] = "Hidden", t2[t2.Disabled = 3] = "Disabled";
}(q || (q = {}));
var Z = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "type", { enumerable: true, configurable: true, writable: true, value: "modern" }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "thumbWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbClipWidth", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbHeight", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "thumbExtraGap", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "shouldCenter", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: q.Init });
  }
  formatThumb(t2, e2) {
    return this.instance.localize(e2, [["%i", t2.index], ["%d", t2.index + 1], ["%s", t2.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"]]);
  }
  getSlides() {
    const t2 = [], e2 = this.option("thumbTpl") || "";
    if (e2)
      for (const i2 of this.instance.slides || []) {
        let n2 = "";
        i2.type && (n2 = `for-${i2.type}`, i2.type && ["video", "youtube", "vimeo", "html5video"].includes(i2.type) && (n2 += " for-video")), t2.push({ html: this.formatThumb(i2, e2), customClass: n2 });
      }
    return t2;
  }
  getProgress(t2) {
    const e2 = this.instance, i2 = e2.panzoom, n2 = e2.pages[t2] || 0;
    if (!n2 || !i2)
      return 0;
    let s2 = -1 * i2.current.e, o2 = e2.contentDim, a2 = (s2 - n2.pos) / (1 * n2.dim), r2 = (s2 + o2 - n2.pos) / (1 * n2.dim), l2 = (s2 - o2 - n2.pos) / (1 * n2.dim);
    return a2 = Math.max(0, Math.min(1, Math.abs(a2))), r2 = Math.max(0, Math.min(1, Math.abs(r2))), l2 = Math.max(0, Math.min(1, Math.abs(l2))), a2 = Math.min(a2, r2, l2), a2;
  }
  onInitSlide(t2, e2) {
    const i2 = e2.el;
    i2 && (e2.thumbSrc = i2.dataset.thumbSrc || e2.thumbSrc || "", e2.thumbClipWidth = parseFloat(i2.dataset.thumbClipWidth || "") || e2.thumbClipWidth || 0, e2.thumbHeight = parseFloat(i2.dataset.thumbHeight || "") || e2.thumbHeight || 0);
  }
  onInitSlides() {
    this.state === q.Init && this.build();
  }
  onRefreshM() {
    this.refreshModern();
  }
  onChangeM() {
    "modern" === this.type && (this.shouldCenter = true, this.centerModern());
  }
  onClickModern(t2) {
    t2.preventDefault(), t2.stopPropagation();
    const e2 = this.instance, i2 = e2.page, n2 = (t3) => {
      if (t3) {
        const e3 = t3.closest("[data-carousel-index]");
        if (e3)
          return parseInt(e3.dataset.carouselIndex || "", 10) || 0;
      }
      return -1;
    }, s2 = (t3, e3) => {
      const i3 = document.elementFromPoint(t3, e3);
      return i3 ? n2(i3) : -1;
    };
    let o2 = n2(t2.target);
    o2 < 0 && (o2 = s2(t2.clientX + this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 - 1)), o2 < 0 && (o2 = s2(t2.clientX - this.thumbGap, t2.clientY), o2 === i2 && (o2 = i2 + 1)), o2 < 0 && (o2 = ((e3) => {
      let n3 = s2(t2.clientX - e3, t2.clientY), a2 = s2(t2.clientX + e3, t2.clientY);
      return o2 < 0 && n3 === i2 && (o2 = i2 + 1), o2 < 0 && a2 === i2 && (o2 = i2 - 1), o2;
    })(this.thumbExtraGap)), o2 === i2 ? this.centerModern() : o2 > -1 && o2 < e2.pages.length && e2.slideTo(o2);
  }
  onTransformM() {
    if ("modern" !== this.type)
      return;
    const { instance: t2, container: e2, track: i2 } = this, n2 = t2.panzoom;
    if (!(e2 && i2 && n2 && this.panzoom))
      return;
    x(e2, this.cn("isResting"), n2.state !== T.Init && n2.isResting);
    let s2 = 0, o2 = 0, a2 = 0;
    for (const e3 of t2.slides) {
      let t3 = e3.index, i3 = e3.thumbSlideEl;
      if (!i3)
        continue;
      o2 = 0, x(i3, this.cn("isSelected"), t3 === this.instance.page), o2 = 1 - this.getProgress(t3), i3.style.setProperty("--progress", o2 ? o2 + "" : "");
      const n3 = 0.5 * ((e3.thumbWidth || 0) - this.thumbClipWidth);
      s2 += n3, o2 && (s2 -= o2 * (n3 + this.thumbExtraGap)), i3.style.setProperty("--shift", s2 + ""), s2 += n3, o2 && (s2 -= o2 * (n3 + this.thumbExtraGap)), s2 -= this.thumbGap, 0 === t3 && (a2 = this.thumbExtraGap * o2);
    }
    i2 && (i2.style.setProperty("--left", a2 + ""), i2.style.setProperty("--width", s2 + a2 + this.thumbGap + this.thumbExtraGap * o2 + "")), this.shouldCenter && this.centerModern();
  }
  buildClassic() {
    const { container: t2, track: i2 } = this, n2 = this.getSlides();
    if (!t2 || !i2 || !n2)
      return;
    const s2 = new this.instance.constructor(t2, e({ track: i2, infinite: false, center: true, fill: true, dragFree: true, slidesPerPage: 1, transition: false, Dots: false, Navigation: false, Sync: {}, classes: { container: "f-thumbs", viewport: "f-thumbs__viewport", track: "f-thumbs__track", slide: "f-thumbs__slide" } }, this.option("Carousel") || {}, { Sync: { target: this.instance }, slides: n2 }));
    this.carousel = s2, this.track = i2, s2.on("ready", () => {
      this.emit("ready");
    });
  }
  buildModern() {
    if ("modern" !== this.type)
      return;
    const { container: t2, track: e2, instance: n2 } = this, s2 = this.option("thumbTpl") || "";
    if (!t2 || !e2 || !s2)
      return;
    R(t2, "is-horizontal"), this.updateModern();
    for (const t3 of n2.slides || []) {
      const n3 = document.createElement("div");
      if (R(n3, this.cn("slide")), t3.type) {
        let e3 = `for-${t3.type}`;
        ["video", "youtube", "vimeo", "html5video"].includes(t3.type) && (e3 += " for-video"), R(n3, e3);
      }
      n3.appendChild(i(this.formatThumb(t3, s2))), t3.thumbSlideEl = n3, e2.appendChild(n3), this.resizeModernSlide(t3);
    }
    const o2 = new n2.constructor.Panzoom(t2, { content: e2, lockAxis: "x", zoom: false, panOnlyZoomed: false, bounds: () => {
      let t3 = 0, e3 = 0, i2 = n2.slides[0], s3 = n2.slides[n2.slides.length - 1], o3 = n2.slides[n2.page];
      return i2 && s3 && o3 && (e3 = -1 * this.getModernThumbPos(0), 0 !== n2.page && (e3 += 0.5 * (i2.thumbWidth || 0)), t3 = -1 * this.getModernThumbPos(n2.slides.length - 1), n2.page !== n2.slides.length - 1 && (t3 += (s3.thumbWidth || 0) - (o3.thumbWidth || 0) - 0.5 * (s3.thumbWidth || 0))), { x: { min: t3, max: e3 }, y: { min: 0, max: 0 } };
    } });
    o2.on("touchStart", () => {
      this.shouldCenter = false;
    }), o2.on("click", (t3, e3) => this.onClickModern(e3)), o2.on("ready", () => {
      this.centerModern(), this.emit("ready");
    }), o2.on(["afterTransform", "refresh"], (t3) => {
      this.lazyLoadModern();
    }), this.panzoom = o2, this.refreshModern();
  }
  updateModern() {
    if ("modern" !== this.type)
      return;
    const { container: t2 } = this;
    t2 && (this.thumbGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-gap")) || 0, this.thumbExtraGap = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-extra-gap")) || 0, this.thumbWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-width")) || 40, this.thumbClipWidth = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-clip-width")) || 40, this.thumbHeight = parseFloat(getComputedStyle(t2).getPropertyValue("--f-thumb-height")) || 40);
  }
  refreshModern() {
    var t2;
    if ("modern" === this.type) {
      this.updateModern();
      for (const t3 of this.instance.slides || [])
        this.resizeModernSlide(t3);
      this.onTransformM(), null === (t2 = this.panzoom) || void 0 === t2 || t2.updateMetrics(true), this.centerModern(0);
    }
  }
  centerModern(t2) {
    const e2 = this.instance, { container: i2, panzoom: n2 } = this;
    if (!i2 || !n2 || n2.state === T.Init)
      return;
    const s2 = e2.page;
    let o2 = this.getModernThumbPos(s2), a2 = o2;
    for (let t3 = e2.page - 3; t3 < e2.page + 3; t3++) {
      if (t3 < 0 || t3 > e2.pages.length - 1 || t3 === e2.page)
        continue;
      const i3 = 1 - this.getProgress(t3);
      i3 > 0 && i3 < 1 && (a2 += i3 * (this.getModernThumbPos(t3) - o2));
    }
    let r2 = 100;
    void 0 === t2 && (t2 = 0.2, e2.inTransition.size > 0 && (t2 = 0.12), Math.abs(-1 * n2.current.e - a2) > n2.containerRect.width && (t2 = 0.5, r2 = 0)), n2.options.maxVelocity = r2, n2.applyChange({ panX: v(-1 * a2 - n2.target.e, 1e3), friction: null === e2.prevPage ? 0 : t2 });
  }
  lazyLoadModern() {
    const { instance: t2, panzoom: e2 } = this;
    if (!e2)
      return;
    const n2 = -1 * e2.current.e || 0;
    let s2 = this.getModernThumbPos(t2.page);
    if (e2.state !== T.Init || 0 === s2)
      for (const s3 of t2.slides || []) {
        const t3 = s3.thumbSlideEl;
        if (!t3)
          continue;
        const o2 = t3.querySelector("img[data-lazy-src]"), r2 = s3.index, l2 = this.getModernThumbPos(r2), c2 = n2 - 0.5 * e2.containerRect.innerWidth, h2 = c2 + e2.containerRect.innerWidth;
        if (!o2 || l2 < c2 || l2 > h2)
          continue;
        let d2 = o2.dataset.lazySrc;
        if (!d2 || !d2.length)
          continue;
        if (delete o2.dataset.lazySrc, o2.src = d2, o2.complete)
          continue;
        R(t3, this.cn("isLoading"));
        const u2 = i(a);
        t3.appendChild(u2), o2.addEventListener("load", () => {
          t3.offsetParent && (t3.classList.remove(this.cn("isLoading")), u2.remove());
        }, false);
      }
  }
  resizeModernSlide(t2) {
    if ("modern" !== this.type)
      return;
    if (!t2.thumbSlideEl)
      return;
    const e2 = t2.thumbClipWidth && t2.thumbHeight ? Math.round(this.thumbHeight * (t2.thumbClipWidth / t2.thumbHeight)) : this.thumbWidth;
    t2.thumbWidth = e2;
  }
  getModernThumbPos(t2) {
    const e2 = this.instance.slides[t2], i2 = this.panzoom;
    if (!i2 || !i2.contentRect.fitWidth)
      return 0;
    let n2 = i2.containerRect.innerWidth, s2 = i2.contentRect.width;
    2 === this.instance.slides.length && (t2 -= 1, s2 = 2 * this.thumbClipWidth);
    let o2 = t2 * (this.thumbClipWidth + this.thumbGap) + this.thumbExtraGap + 0.5 * (e2.thumbWidth || 0);
    return o2 -= s2 > n2 ? 0.5 * n2 : 0.5 * s2, v(o2 || 0, 1);
  }
  build() {
    const t2 = this.instance, e2 = t2.container, i2 = this.option("minCount") || 0;
    if (i2) {
      let e3 = 0;
      for (const i3 of t2.slides || [])
        i3.thumbSrc && e3++;
      if (e3 < i2)
        return this.cleanup(), void (this.state = q.Disabled);
    }
    const n2 = this.option("type");
    if (["modern", "classic"].indexOf(n2) < 0)
      return void (this.state = q.Disabled);
    this.type = n2;
    const s2 = document.createElement("div");
    R(s2, this.cn("container")), R(s2, `is-${n2}`);
    const o2 = this.option("parentEl");
    o2 ? o2.appendChild(s2) : e2.after(s2), this.container = s2, R(e2, this.cn("hasThumbs"));
    const a2 = document.createElement("div");
    R(a2, this.cn("track")), s2.appendChild(a2), this.track = a2, "classic" === n2 ? this.buildClassic() : this.buildModern(), this.state = q.Ready;
  }
  cleanup() {
    this.carousel && this.carousel.destroy(), this.carousel = null, this.panzoom && this.panzoom.destroy(), this.panzoom = null, this.container && this.container.remove(), this.container = null, this.track = null, this.state = q.Init, z(this.instance.container, this.cn("hasThumbs"));
  }
  attach() {
    this.instance.on("initSlide", this.onInitSlide), this.instance.on("initSlides", this.onInitSlides), this.instance.on("Panzoom.afterTransform", this.onTransformM), this.instance.on("Panzoom.refresh", this.onRefreshM), this.instance.on("change", this.onChangeM);
  }
  detach() {
    this.instance.off("initSlide", this.onInitSlide), this.instance.off("initSlides", this.onInitSlides), this.instance.off("Panzoom.afterTransform", this.onTransformM), this.instance.off("Panzoom.refresh", this.onRefreshM), this.instance.off("change", this.onChangeM), this.cleanup();
  }
};
Object.defineProperty(Z, "defaults", { enumerable: true, configurable: true, writable: true, value: Y });
var V = Object.assign(Object.assign({}, Y), { key: "t", showOnStart: true, parentEl: null });
var G = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "ref", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hidden", { enumerable: true, configurable: true, writable: true, value: false });
  }
  get isEnabled() {
    const t2 = this.ref;
    return t2 && t2.state !== q.Disabled;
  }
  get isHidden() {
    return this.hidden;
  }
  onInit() {
    const t2 = this.instance, i2 = t2.carousel;
    if (!i2)
      return;
    const n2 = this.option("parentEl") || t2.footer || t2.container;
    n2 && (i2.options.Thumbs = e({}, this.options, { parentEl: n2, classes: { container: "f-thumbs fancybox__thumbs" }, Carousel: { Sync: { friction: t2.option("Carousel.friction") }, on: { click: (t3, e2) => {
      e2.stopPropagation();
    } } }, on: { ready: (t3) => {
      const e2 = t3.container;
      e2 && this.hidden && (this.refresh(), e2.style.transition = "none", this.hide(), e2.offsetHeight, queueMicrotask(() => {
        e2.style.transition = "", this.show();
      }));
    } } }), i2.attachPlugins({ Thumbs: Z }), this.ref = i2.plugins.Thumbs, this.option("showOnStart") || (this.ref.state = q.Hidden, this.hidden = true));
  }
  onResize() {
    var t2;
    const e2 = null === (t2 = this.ref) || void 0 === t2 ? void 0 : t2.container;
    e2 && (e2.style.maxHeight = "");
  }
  onKeydown(t2, e2) {
    const i2 = this.option("key");
    i2 && i2 === e2 && this.toggle();
  }
  toggle() {
    const t2 = this.ref;
    t2 && t2.state !== q.Disabled && (t2.state !== q.Hidden ? this.hidden ? this.show() : this.hide() : t2.build());
  }
  show() {
    const t2 = this.ref, e2 = t2 && t2.state !== q.Disabled && t2.container;
    e2 && (this.refresh(), e2.offsetHeight, e2.removeAttribute("aria-hidden"), e2.classList.remove("is-hidden"), this.hidden = false);
  }
  hide() {
    const t2 = this.ref, e2 = t2 && t2.container;
    e2 && (this.refresh(), e2.offsetHeight, e2.classList.add("is-hidden"), e2.setAttribute("aria-hidden", "true")), this.hidden = true;
  }
  refresh() {
    const t2 = this.ref;
    if (!t2 || t2.state === q.Disabled)
      return;
    const e2 = t2.container, i2 = (null == e2 ? void 0 : e2.firstChild) || null;
    e2 && i2 && i2.childNodes.length && (e2.style.maxHeight = `${i2.getBoundingClientRect().height}px`);
  }
  attach() {
    this.instance.on("Carousel.init", this.onInit), this.instance.on("resize", this.onResize), this.instance.on("keydown", this.onKeydown);
  }
  detach() {
    this.instance.off("Carousel.init", this.onInit), this.instance.off("resize", this.onResize), this.instance.off("keydown", this.onKeydown);
  }
};
Object.defineProperty(G, "defaults", { enumerable: true, configurable: true, writable: true, value: V });
var U = { panLeft: { icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>', change: { panX: -100 } }, panRight: { icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>', change: { panX: 100 } }, panUp: { icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>', change: { panY: -100 } }, panDown: { icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>', change: { panY: 100 } }, zoomIn: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>', action: "zoomIn" }, zoomOut: { icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "zoomOut" }, toggle1to1: { icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>', action: "toggleZoom" }, toggleZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "toggleZoom" }, iterateZoom: { icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>', action: "iterateZoom" }, rotateCCW: { icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>', action: "rotateCCW" }, rotateCW: { icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>', action: "rotateCW" }, flipX: { icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>', action: "flipX" }, flipY: { icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>', action: "flipY" }, fitX: { icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>', action: "fitX" }, fitY: { icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>', action: "fitY" }, reset: { icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>', action: "reset" }, toggleFS: { icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>', action: "toggleFS" } };
var K;
!function(t2) {
  t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Disabled = 2] = "Disabled";
}(K || (K = {}));
var J = { absolute: "auto", display: { left: ["infobar"], middle: [], right: ["iterateZoom", "slideshow", "fullscreen", "thumbs", "close"] }, enabled: "auto", items: { infobar: { tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>' }, download: { tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>' }, prev: { tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>' }, next: { tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>' }, slideshow: { tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>' }, fullscreen: { tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>' }, thumbs: { tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>' }, close: { tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>' } }, parentEl: null };
var Q = { tabindex: "-1", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" };
var tt = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: K.Init }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null });
  }
  onReady(t2) {
    var e2;
    if (!t2.carousel)
      return;
    let i2 = this.option("display"), n2 = this.option("absolute"), s2 = this.option("enabled");
    if ("auto" === s2) {
      const t3 = this.instance.carousel;
      let e3 = 0;
      if (t3)
        for (const i3 of t3.slides)
          (i3.panzoom || "image" === i3.type) && e3++;
      e3 || (s2 = false);
    }
    s2 || (i2 = void 0);
    let o2 = 0;
    const a2 = { left: [], middle: [], right: [] };
    if (i2)
      for (const t3 of ["left", "middle", "right"])
        for (const n3 of i2[t3]) {
          const i3 = this.createEl(n3);
          i3 && (null === (e2 = a2[t3]) || void 0 === e2 || e2.push(i3), o2++);
        }
    let r2 = null;
    if (o2 && (r2 = this.createContainer()), r2) {
      for (const [t3, e3] of Object.entries(a2)) {
        const i3 = document.createElement("div");
        R(i3, "fancybox__toolbar__column is-" + t3);
        for (const t4 of e3)
          i3.appendChild(t4);
        "auto" !== n2 || "middle" !== t3 || e3.length || (n2 = true), r2.appendChild(i3);
      }
      true === n2 && R(r2, "is-absolute"), this.state = K.Ready, this.onRefresh();
    } else
      this.state = K.Disabled;
  }
  onClick(t2) {
    var e2, i2;
    const n2 = this.instance, s2 = n2.getSlide(), o2 = null == s2 ? void 0 : s2.panzoom, a2 = t2.target, r2 = a2 && L(a2) ? a2.dataset : null;
    if (!r2)
      return;
    if (void 0 !== r2.fancyboxToggleThumbs)
      return t2.preventDefault(), t2.stopPropagation(), void (null === (e2 = n2.plugins.Thumbs) || void 0 === e2 || e2.toggle());
    if (void 0 !== r2.fancyboxToggleFullscreen)
      return t2.preventDefault(), t2.stopPropagation(), void this.instance.toggleFullscreen();
    if (void 0 !== r2.fancyboxToggleSlideshow) {
      t2.preventDefault(), t2.stopPropagation();
      const e3 = null === (i2 = n2.carousel) || void 0 === i2 ? void 0 : i2.plugins.Autoplay;
      let s3 = e3.isActive;
      return o2 && "mousemove" === o2.panMode && !s3 && o2.reset(), void (s3 ? e3.stop() : e3.start());
    }
    const l2 = r2.panzoomAction, c2 = r2.panzoomChange;
    if ((c2 || l2) && (t2.preventDefault(), t2.stopPropagation()), c2) {
      let t3 = {};
      try {
        t3 = JSON.parse(c2);
      } catch (t4) {
      }
      o2 && o2.applyChange(t3);
    } else
      l2 && o2 && o2[l2] && o2[l2]();
  }
  onChange() {
    this.onRefresh();
  }
  onRefresh() {
    if (this.instance.isClosing())
      return;
    const t2 = this.container;
    if (!t2)
      return;
    const e2 = this.instance.getSlide();
    if (!e2 || e2.state !== h.Ready)
      return;
    const i2 = e2 && !e2.error && e2.panzoom;
    for (const e3 of t2.querySelectorAll("[data-panzoom-action]"))
      i2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
    let n2 = i2 && i2.canZoomIn(), s2 = i2 && i2.canZoomOut();
    for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomIn"]'))
      n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
    for (const e3 of t2.querySelectorAll('[data-panzoom-action="zoomOut"]'))
      s2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
    for (const e3 of t2.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
      s2 || n2 ? (e3.removeAttribute("disabled"), e3.removeAttribute("tabindex")) : (e3.setAttribute("disabled", ""), e3.setAttribute("tabindex", "-1"));
      const t3 = e3.querySelector("g");
      t3 && (t3.style.display = n2 ? "" : "none");
    }
  }
  onDone(t2, e2) {
    var i2;
    null === (i2 = e2.panzoom) || void 0 === i2 || i2.on("afterTransform", () => {
      this.instance.isCurrentSlide(e2) && this.onRefresh();
    }), this.instance.isCurrentSlide(e2) && this.onRefresh();
  }
  createContainer() {
    const t2 = this.instance.container;
    if (!t2)
      return null;
    const e2 = this.option("parentEl") || t2, i2 = document.createElement("div");
    return R(i2, "fancybox__toolbar"), e2.prepend(i2), i2.addEventListener("click", this.onClick, { passive: false, capture: true }), t2 && R(t2, "has-toolbar"), this.container = i2, i2;
  }
  createEl(t2) {
    var e2;
    const n2 = this.instance.carousel;
    if (!n2)
      return null;
    if ("toggleFS" === t2)
      return null;
    if ("fullscreen" === t2 && !this.instance.fsAPI)
      return null;
    let s2 = null;
    const o2 = n2.slides.length || 0;
    let a2 = 0, r2 = 0;
    for (const t3 of n2.slides)
      (t3.panzoom || "image" === t3.type) && a2++, ("image" === t3.type || t3.downloadSrc) && r2++;
    if (o2 < 2 && ["infobar", "prev", "next"].includes(t2))
      return s2;
    if (void 0 !== U[t2] && !a2)
      return null;
    if ("download" === t2 && !r2)
      return null;
    if ("thumbs" === t2) {
      const t3 = this.instance.plugins.Thumbs;
      if (!t3 || !t3.isEnabled)
        return null;
    }
    if ("slideshow" === t2) {
      if (!(null === (e2 = this.instance.carousel) || void 0 === e2 ? void 0 : e2.plugins.Autoplay) || o2 < 2)
        return null;
    }
    if (void 0 !== U[t2]) {
      const e3 = U[t2];
      s2 = document.createElement("button"), s2.setAttribute("title", this.instance.localize(`{{${t2.toUpperCase()}}}`)), R(s2, "f-button"), e3.action && (s2.dataset.panzoomAction = e3.action), e3.change && (s2.dataset.panzoomChange = JSON.stringify(e3.change)), s2.appendChild(i(this.instance.localize(e3.icon)));
    } else {
      const e3 = (this.option("items") || [])[t2];
      e3 && (s2 = i(this.instance.localize(e3.tpl)), "function" == typeof e3.click && s2.addEventListener("click", (t3) => {
        t3.preventDefault(), t3.stopPropagation(), "function" == typeof e3.click && e3.click.call(this, this, t3);
      }));
    }
    const l2 = null == s2 ? void 0 : s2.querySelector("svg");
    if (l2)
      for (const [t3, e3] of Object.entries(Q))
        l2.getAttribute(t3) || l2.setAttribute(t3, String(e3));
    return s2;
  }
  removeContainer() {
    var t2;
    const e2 = this.container;
    e2 && e2.removeEventListener("click", this.onClick, { passive: false, capture: true }), null === (t2 = this.container) || void 0 === t2 || t2.remove(), this.container = null, this.state = K.Disabled;
    const i2 = this.instance.container;
    i2 && z(i2, "has-toolbar");
  }
  attach() {
    this.instance.on("Carousel.initSlides", this.onReady), this.instance.on("done", this.onDone), this.instance.on("reveal", this.onChange), this.instance.on("Carousel.change", this.onChange), this.onReady(this.instance);
  }
  detach() {
    this.instance.off("Carousel.initSlides", this.onReady), this.instance.off("done", this.onDone), this.instance.off("reveal", this.onChange), this.instance.off("Carousel.change", this.onChange), this.removeContainer();
  }
};
Object.defineProperty(tt, "defaults", { enumerable: true, configurable: true, writable: true, value: J });
var et = { Hash: g, Html: W, Images: H, Slideshow: X, Thumbs: G, Toolbar: tt };
var it = function(t2, e2) {
  let i2 = true;
  return (...n2) => {
    i2 && (i2 = false, t2(...n2), setTimeout(() => {
      i2 = true;
    }, e2));
  };
};
var nt = (t2, e2) => {
  let i2 = [];
  return t2.childNodes.forEach((t3) => {
    t3.nodeType !== Node.ELEMENT_NODE || e2 && !t3.matches(e2) || i2.push(t3);
  }), i2;
};
var st = { viewport: null, track: null, enabled: true, slides: [], axis: "x", transition: "fade", preload: 1, slidesPerPage: "auto", initialPage: 0, friction: 0.12, Panzoom: { decelFriction: 0.12 }, center: true, infinite: true, fill: true, dragFree: false, adaptiveHeight: false, direction: "ltr", classes: { container: "f-carousel", viewport: "f-carousel__viewport", track: "f-carousel__track", slide: "f-carousel__slide", isLTR: "is-ltr", isRTL: "is-rtl", isHorizontal: "is-horizontal", isVertical: "is-vertical", inTransition: "in-transition", isSelected: "is-selected" }, l10n: { NEXT: "Next slide", PREV: "Previous slide", GOTO: "Go to slide #%d" } };
var ot;
!function(t2) {
  t2[t2.Init = 0] = "Init", t2[t2.Ready = 1] = "Ready", t2[t2.Destroy = 2] = "Destroy";
}(ot || (ot = {}));
var at = (t2) => {
  if ("string" == typeof t2 && (t2 = { html: t2 }), !(t2 instanceof String || t2 instanceof HTMLElement)) {
    const e2 = t2.thumb;
    void 0 !== e2 && ("string" == typeof e2 && (t2.thumbSrc = e2), e2 instanceof HTMLImageElement && (t2.thumbEl = e2, t2.thumbElSrc = e2.src, t2.thumbSrc = e2.src), delete t2.thumb);
  }
  return Object.assign({ html: "", el: null, isDom: false, class: "", index: -1, dim: 0, gap: 0, pos: 0, transition: false }, t2);
};
var rt = (t2 = {}) => Object.assign({ index: -1, slides: [], dim: 0, pos: -1 }, t2);
var lt = { classes: { list: "f-carousel__dots", isDynamic: "is-dynamic", hasDots: "has-dots", dot: "f-carousel__dot", isBeforePrev: "is-before-prev", isPrev: "is-prev", isCurrent: "is-current", isNext: "is-next", isAfterNext: "is-after-next" }, dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>', dynamicFrom: 11, maxCount: 1 / 0, minCount: 2 };
var ct = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "isDynamic", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "list", { enumerable: true, configurable: true, writable: true, value: null });
  }
  onRefresh() {
    this.refresh();
  }
  build() {
    let t2 = this.list;
    return t2 || (t2 = document.createElement("ul"), R(t2, this.cn("list")), t2.setAttribute("role", "tablist"), this.instance.container.appendChild(t2), R(this.instance.container, this.cn("hasDots")), this.list = t2), t2;
  }
  refresh() {
    var t2;
    const e2 = this.instance.pages.length, i2 = Math.min(2, this.option("minCount")), n2 = Math.max(2e3, this.option("maxCount")), s2 = this.option("dynamicFrom");
    if (e2 < i2 || e2 > n2)
      return void this.cleanup();
    const o2 = "number" == typeof s2 && e2 > 5 && e2 >= s2, a2 = !this.list || this.isDynamic !== o2 || this.list.children.length !== e2;
    a2 && this.cleanup();
    const r2 = this.build();
    if (x(r2, this.cn("isDynamic"), !!o2), a2)
      for (let t3 = 0; t3 < e2; t3++)
        r2.append(this.createItem(t3));
    let l2, c2 = 0;
    for (const e3 of [...r2.children]) {
      const i3 = c2 === this.instance.page;
      i3 && (l2 = e3), x(e3, this.cn("isCurrent"), i3), null === (t2 = e3.children[0]) || void 0 === t2 || t2.setAttribute("aria-selected", i3 ? "true" : "false");
      for (const t3 of ["isBeforePrev", "isPrev", "isNext", "isAfterNext"])
        z(e3, this.cn(t3));
      c2++;
    }
    if (l2 = l2 || r2.firstChild, o2 && l2) {
      const t3 = l2.previousElementSibling, e3 = t3 && t3.previousElementSibling;
      R(t3, this.cn("isPrev")), R(e3, this.cn("isBeforePrev"));
      const i3 = l2.nextElementSibling, n3 = i3 && i3.nextElementSibling;
      R(i3, this.cn("isNext")), R(n3, this.cn("isAfterNext"));
    }
    this.isDynamic = o2;
  }
  createItem(t2 = 0) {
    var e2;
    const n2 = document.createElement("li");
    n2.setAttribute("role", "presentation");
    const s2 = i(this.instance.localize(this.option("dotTpl"), [["%d", t2 + 1]]).replace(/\%i/g, t2 + ""));
    return n2.appendChild(s2), null === (e2 = n2.children[0]) || void 0 === e2 || e2.setAttribute("role", "tab"), n2;
  }
  cleanup() {
    this.list && (this.list.remove(), this.list = null), this.isDynamic = false, z(this.instance.container, this.cn("hasDots"));
  }
  attach() {
    this.instance.on(["refresh", "change"], this.onRefresh);
  }
  detach() {
    this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
  }
};
Object.defineProperty(ct, "defaults", { enumerable: true, configurable: true, writable: true, value: lt });
var ht = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prev", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "next", { enumerable: true, configurable: true, writable: true, value: null });
  }
  onRefresh() {
    const t2 = this.instance, e2 = t2.pages.length, i2 = t2.page;
    if (e2 < 2)
      return void this.cleanup();
    this.build();
    let n2 = this.prev, s2 = this.next;
    n2 && s2 && (n2.removeAttribute("disabled"), s2.removeAttribute("disabled"), t2.isInfinite || (i2 <= 0 && n2.setAttribute("disabled", ""), i2 >= e2 - 1 && s2.setAttribute("disabled", "")));
  }
  createButton(t2) {
    const e2 = this.instance, i2 = document.createElement("button");
    i2.setAttribute("tabindex", "0"), i2.setAttribute("title", e2.localize(`{{${t2.toUpperCase()}}}`)), R(i2, this.cn("button") + " " + this.cn("next" === t2 ? "isNext" : "isPrev"));
    const n2 = e2.isRTL ? "next" === t2 ? "prev" : "next" : t2;
    var s2;
    return i2.innerHTML = e2.localize(this.option(`${n2}Tpl`)), i2.dataset[`carousel${s2 = t2, s2 ? s2.match("^[a-z]") ? s2.charAt(0).toUpperCase() + s2.substring(1) : s2 : ""}`] = "true", i2;
  }
  build() {
    let t2 = this.container;
    t2 || (this.container = t2 = document.createElement("div"), R(t2, this.cn("container")), this.instance.container.appendChild(t2)), this.next || (this.next = t2.appendChild(this.createButton("next"))), this.prev || (this.prev = t2.appendChild(this.createButton("prev")));
  }
  cleanup() {
    this.prev && this.prev.remove(), this.next && this.next.remove(), this.container && this.container.remove(), this.prev = null, this.next = null, this.container = null;
  }
  attach() {
    this.instance.on(["refresh", "change"], this.onRefresh);
  }
  detach() {
    this.instance.off(["refresh", "change"], this.onRefresh), this.cleanup();
  }
};
Object.defineProperty(ht, "defaults", { enumerable: true, configurable: true, writable: true, value: { classes: { container: "f-carousel__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" }, nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>', prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>' } });
var dt = class extends m {
  constructor() {
    super(...arguments), Object.defineProperty(this, "selectedIndex", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "target", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "nav", { enumerable: true, configurable: true, writable: true, value: null });
  }
  addAsTargetFor(t2) {
    this.target = this.instance, this.nav = t2, this.attachEvents();
  }
  addAsNavFor(t2) {
    this.nav = this.instance, this.target = t2, this.attachEvents();
  }
  attachEvents() {
    this.nav && this.target && (this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.state === ot.Ready && this.onNavReady(this.nav), this.target.on("ready", this.onTargetReady), this.target.state === ot.Ready && this.onTargetReady(this.target));
  }
  onNavReady(t2) {
    t2.on("createSlide", this.onNavCreateSlide), t2.on("Panzoom.click", this.onNavClick), t2.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
  }
  onTargetReady(t2) {
    t2.on("change", this.onTargetChange), t2.on("Panzoom.refresh", this.onTargetChange), this.onTargetChange();
  }
  onNavClick(t2, e2, i2) {
    i2.pointerType || this.onNavTouch(t2, t2.panzoom, i2);
  }
  onNavTouch(t2, e2, i2) {
    var n2, s2;
    if (Math.abs(e2.dragOffset.x) > 3 || Math.abs(e2.dragOffset.y) > 3)
      return;
    const o2 = i2.target, { nav: a2, target: r2 } = this;
    if (!a2 || !r2 || !o2)
      return;
    const l2 = o2.closest("[data-index]");
    if (i2.stopPropagation(), i2.stopImmediatePropagation(), i2.preventDefault(), !l2)
      return;
    const c2 = parseInt(l2.dataset.index || "", 10) || 0, h2 = r2.getPageForSlide(c2), d2 = a2.getPageForSlide(c2);
    a2.slideTo(d2), r2.slideTo(h2, { friction: null === (s2 = null === (n2 = this.nav) || void 0 === n2 ? void 0 : n2.plugins) || void 0 === s2 ? void 0 : s2.Sync.option("friction") }), this.markSelectedSlide(c2);
  }
  onNavCreateSlide(t2, e2) {
    e2.index === this.selectedIndex && this.markSelectedSlide(e2.index);
  }
  onTargetChange() {
    const { target: t2, nav: e2 } = this;
    if (!t2 || !e2)
      return;
    if (e2.state !== ot.Ready || t2.state !== ot.Ready)
      return;
    const i2 = t2.pages[t2.page].slides[0].index, n2 = e2.getPageForSlide(i2);
    this.markSelectedSlide(i2), e2.slideTo(n2);
  }
  markSelectedSlide(t2) {
    const { nav: e2 } = this;
    if (!e2 || e2.state !== ot.Ready)
      return;
    this.selectedIndex = t2, [...e2.slides].filter((t3) => t3.el && t3.el.classList.remove("is-nav-selected"));
    const i2 = e2.slides[t2];
    i2 && i2.el && i2.el.classList.add("is-nav-selected");
  }
  attach() {
    let t2 = this.options.target, e2 = this.options.nav;
    t2 ? this.addAsNavFor(t2) : e2 && this.addAsTargetFor(e2);
  }
  detach() {
    this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("createSlide", this.onNavCreateSlide), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("Panzoom.touchEnd", this.onNavTouch)), this.nav = null, this.target && (this.target.off("ready", this.onTargetReady), this.target.off("refresh", this.onTargetChange), this.target.off("change", this.onTargetChange)), this.target = null;
  }
};
Object.defineProperty(dt, "defaults", { enumerable: true, configurable: true, writable: true, value: { friction: 0.35 } });
var ut = { Navigation: ht, Dots: ct, Sync: dt };
var pt = class extends p {
  get axis() {
    return this.isHorizontal ? "e" : "f";
  }
  get isEnabled() {
    return this.state === ot.Ready;
  }
  get isInfinite() {
    let t2 = false;
    const e2 = this.contentDim, i2 = this.viewportDim;
    return this.pages.length >= 2 && e2 > 1.5 * i2 && (t2 = this.option("infinite")), t2;
  }
  get isRTL() {
    return "rtl" === this.option("direction");
  }
  get isHorizontal() {
    return "x" === this.option("axis");
  }
  constructor(t2, e2 = {}, i2 = {}) {
    if (super(), Object.defineProperty(this, "userOptions", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "bp", { enumerable: true, configurable: true, writable: true, value: "" }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: ot.Init }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "prevPage", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "viewport", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "track", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "slides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "pages", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "panzoom", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "inTransition", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "contentDim", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "viewportDim", { enumerable: true, configurable: true, writable: true, value: 0 }), "string" == typeof t2 && (t2 = document.querySelector(t2)), !t2 || !L(t2))
      throw new Error("No Element found");
    this.container = t2, this.slideNext = it(this.slideNext.bind(this), 150), this.slidePrev = it(this.slidePrev.bind(this), 150), this.userOptions = e2, this.userPlugins = i2, queueMicrotask(() => {
      this.processOptions();
    });
  }
  processOptions() {
    const i2 = e({}, pt.defaults, this.userOptions);
    let n2 = "";
    const s2 = i2.breakpoints;
    if (s2 && t(s2))
      for (const [o2, a2] of Object.entries(s2))
        window.matchMedia(o2).matches && t(a2) && (n2 += o2, e(i2, a2));
    n2 === this.bp && this.state !== ot.Init || (this.bp = n2, this.state === ot.Ready && (i2.initialSlide = this.pages[this.page].slides[0].index), this.state !== ot.Init && this.destroy(), super.setOptions(i2), false === this.option("enabled") ? this.attachEvents() : setTimeout(() => {
      this.init();
    }, 0));
  }
  init() {
    this.state = ot.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, pt.Plugins), this.userPlugins)), this.initLayout(), this.initSlides(), this.updateMetrics(), this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = ot.Ready, this.emit("ready");
  }
  initLayout() {
    const { container: t2 } = this, e2 = this.option("classes");
    R(t2, this.cn("container")), x(t2, e2.isLTR, !this.isRTL), x(t2, e2.isRTL, this.isRTL), x(t2, e2.isVertical, !this.isHorizontal), x(t2, e2.isHorizontal, this.isHorizontal);
    let i2 = this.option("viewport") || t2.querySelector(`.${e2.viewport}`);
    i2 || (i2 = document.createElement("div"), R(i2, e2.viewport), i2.append(...nt(t2, `.${e2.slide}`)), t2.prepend(i2));
    let n2 = this.option("track") || t2.querySelector(`.${e2.track}`);
    n2 || (n2 = document.createElement("div"), R(n2, e2.track), n2.append(...Array.from(i2.childNodes))), n2.setAttribute("aria-live", "polite"), i2.contains(n2) || i2.prepend(n2), this.viewport = i2, this.track = n2, this.emit("initLayout");
  }
  initSlides() {
    const { track: t2 } = this;
    if (t2) {
      this.slides = [], [...nt(t2, `.${this.cn("slide")}`)].forEach((t3) => {
        if (L(t3)) {
          const e2 = at({ el: t3, isDom: true, index: this.slides.length });
          this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
        }
      });
      for (let t3 of this.option("slides", [])) {
        const e2 = at(t3);
        e2.index = this.slides.length, this.slides.push(e2), this.emit("initSlide", e2, this.slides.length);
      }
      this.emit("initSlides");
    }
  }
  setInitialPage() {
    let t2 = 0;
    const e2 = this.option("initialSlide");
    t2 = "number" == typeof e2 ? this.getPageForSlide(e2) : parseInt(this.option("initialPage", 0) + "", 10) || 0, this.page = t2;
  }
  setInitialPosition() {
    if (!this.track || !this.pages.length)
      return;
    const t2 = this.isHorizontal;
    let e2 = this.page;
    this.pages[e2] || (this.page = e2 = 0);
    const i2 = this.pages[e2].pos * (this.isRTL && t2 ? 1 : -1), n2 = t2 ? `${i2}px` : "0", s2 = t2 ? "0" : `${i2}px`;
    this.track.style.transform = `translate3d(${n2}, ${s2}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
  }
  initPanzoom() {
    this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
    const t2 = this.option("Panzoom") || {};
    this.panzoom = new F(this.viewport, e({}, { content: this.track, zoom: false, panOnlyZoomed: false, lockAxis: this.isHorizontal ? "x" : "y", infinite: this.isInfinite, click: false, dblClick: false, touch: (t3) => !(this.pages.length < 2 && !t3.options.infinite), bounds: () => this.getBounds(), maxVelocity: (t3) => Math.abs(t3.target[this.axis] - t3.current[this.axis]) < 2 * this.viewportDim ? 100 : 0 }, t2)), this.panzoom.on("*", (t3, e2, ...i2) => {
      this.emit(`Panzoom.${e2}`, t3, ...i2);
    }), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
  }
  attachEvents() {
    const t2 = this.container;
    t2 && (t2.addEventListener("click", this.onClick, { passive: false, capture: false }), t2.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
  }
  createPages() {
    let t2 = [];
    const { contentDim: e2, viewportDim: i2 } = this, n2 = this.option("slidesPerPage");
    if ("number" == typeof n2 && e2 > i2) {
      for (let e3 = 0; e3 < this.slides.length; e3 += n2)
        t2.push(rt({ index: e3, slides: this.slides.slice(e3, e3 + n2) }));
      return t2;
    }
    let s2 = 0, o2 = 0;
    for (const e3 of this.slides)
      (!t2.length || o2 + e3.dim > i2) && (t2.push(rt()), s2 = t2.length - 1, o2 = 0), o2 += e3.dim + e3.gap, t2[s2].slides.push(e3);
    return t2;
  }
  processPages() {
    const t2 = this.pages, { contentDim: e2, viewportDim: i2 } = this, n2 = this.option("center"), s2 = this.option("fill"), o2 = s2 && n2 && e2 > i2 && !this.isInfinite;
    if (t2.forEach((t3, s3) => {
      t3.index = s3, t3.pos = t3.slides[0].pos, t3.dim = 0;
      for (const [e3, i3] of t3.slides.entries())
        t3.dim += i3.dim, e3 < t3.slides.length - 1 && (t3.dim += i3.gap);
      o2 && t3.pos + 0.5 * t3.dim < 0.5 * i2 ? t3.pos = 0 : o2 && t3.pos + 0.5 * t3.dim >= e2 - 0.5 * i2 ? t3.pos = e2 - i2 : n2 && (t3.pos += -0.5 * (i2 - t3.dim));
    }), t2.forEach((t3, n3) => {
      s2 && !this.isInfinite && e2 > i2 && (t3.pos = Math.max(t3.pos, 0), t3.pos = Math.min(t3.pos, e2 - i2)), t3.pos = v(t3.pos, 1e3), t3.dim = v(t3.dim, 1e3), t3.pos < 0.1 && t3.pos > -0.1 && (t3.pos = 0);
    }), this.isInfinite)
      return t2;
    const a2 = [];
    let r2;
    return t2.forEach((t3) => {
      const e3 = Object.assign({}, t3);
      r2 && e3.pos === r2.pos ? (r2.dim += e3.dim, r2.slides = [...r2.slides, ...e3.slides]) : (e3.index = a2.length, r2 = e3, a2.push(e3));
    }), a2;
  }
  getPageFromIndex(t2 = 0) {
    const e2 = this.pages.length;
    let i2;
    return t2 = parseInt((t2 || 0).toString()) || 0, i2 = this.isInfinite ? (t2 % e2 + e2) % e2 : Math.max(Math.min(t2, this.pages.length - 1), 0), i2;
  }
  getSlideMetrics(t2) {
    const e2 = this.isHorizontal ? "width" : "height";
    let i2 = 0, n2 = 0, s2 = t2.el;
    s2 ? i2 = parseFloat(s2.dataset[e2] || "") || 0 : (s2 = document.createElement("div"), s2.style.visibility = "hidden", R(s2, this.cn("slide") + " " + t2.class), (this.track || document.body).prepend(s2)), i2 ? (s2.style[e2] = `${i2}px`, s2.style["width" === e2 ? "height" : "width"] = "") : i2 = s2.getBoundingClientRect()[e2];
    const o2 = getComputedStyle(s2);
    return "content-box" === o2.boxSizing && (this.isHorizontal ? (i2 += parseFloat(o2.paddingLeft) || 0, i2 += parseFloat(o2.paddingRight) || 0) : (i2 += parseFloat(o2.paddingTop) || 0, i2 += parseFloat(o2.paddingBottom) || 0)), n2 = parseFloat(o2[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, this.isHorizontal, t2.el || s2.remove(), { dim: v(i2, 1e3), gap: v(n2, 1e3) };
  }
  getBounds() {
    let t2 = { min: 0, max: 0 };
    if (this.isInfinite)
      t2 = { min: -1 / 0, max: 1 / 0 };
    else if (this.pages.length) {
      const e2 = this.pages[0].pos, i2 = this.pages[this.pages.length - 1].pos;
      t2 = this.isRTL && this.isHorizontal ? { min: e2, max: i2 } : { min: -1 * i2, max: -1 * e2 };
    }
    return { x: this.isHorizontal ? t2 : { min: 0, max: 0 }, y: this.isHorizontal ? { min: 0, max: 0 } : t2 };
  }
  repositionSlides() {
    const { viewportDim: t2, contentDim: e2, page: i2, pages: n2 } = this;
    let s2, o2 = 0, a2 = 0, r2 = 0, l2 = 0;
    this.panzoom ? l2 = -1 * this.panzoom.current[this.isHorizontal ? "e" : "f"] : n2[i2] && (l2 = n2[i2].pos || 0), s2 = this.isHorizontal ? this.isRTL ? "right" : "left" : "top", this.isRTL && this.isHorizontal && (l2 *= -1);
    for (const t3 of this.slides)
      t3.el ? ("top" === s2 ? (t3.el.style.right = "", t3.el.style.left = "") : t3.el.style.top = "", t3.index !== o2 ? t3.el.style[s2] = 0 === a2 ? "" : `${v(a2, 1e3)}px` : t3.el.style[s2] = "", r2 += t3.dim + t3.gap, o2++) : a2 += t3.dim + t3.gap;
    if (this.isInfinite && r2)
      for (const i3 of this.slides)
        i3.el && (v(i3.pos) < v(t2) && v(i3.pos + i3.dim + i3.gap) < v(l2) && v(l2) > v(e2 - t2) && (i3.el.style[s2] = `${v(a2 + r2, 1e3)}px`), v(i3.pos + i3.gap) >= v(e2 - t2) && v(i3.pos) > v(l2 + t2) && v(l2) < v(t2) && (i3.el.style[s2] = `-${v(r2, 1e3)}px`));
    let c2, h2, d2 = [...this.inTransition];
    if (d2.length > 1 && (c2 = this.pages[d2[0]], h2 = this.pages[d2[1]]), c2 && h2) {
      let t3 = 0;
      for (const e3 of this.slides)
        e3.el ? this.inTransition.has(e3.index) && c2.slides.indexOf(e3) < 0 && (e3.el.style[s2] = `${v(t3 + (c2.pos - h2.pos), 1e3)}px`) : t3 += e3.dim + e3.gap;
    }
  }
  createSlideEl(t2) {
    if (!this.track || !t2)
      return;
    if (t2.el)
      return;
    const e2 = document.createElement("div");
    R(e2, this.cn("slide")), R(e2, t2.class), R(e2, t2.customClass), t2.html && (e2.innerHTML = t2.html);
    const i2 = [];
    this.slides.forEach((t3, e3) => {
      t3.el && i2.push(e3);
    });
    const n2 = t2.index;
    let s2 = null;
    if (i2.length) {
      let t3 = i2.reduce((t4, e3) => Math.abs(e3 - n2) < Math.abs(t4 - n2) ? e3 : t4);
      s2 = this.slides[t3];
    }
    const o2 = s2 && s2.el ? s2.index < t2.index ? s2.el.nextSibling : s2.el : null;
    this.track.insertBefore(e2, this.track.contains(o2) ? o2 : null), t2.el = e2, this.emit("createSlide", t2);
  }
  removeSlideEl(t2, e2 = false) {
    const i2 = t2.el;
    if (!i2)
      return;
    if (z(i2, this.cn("isSelected")), t2.isDom && !e2)
      return void (i2.style.left = "");
    this.emit("removeSlide", t2);
    const n2 = new CustomEvent("animationend");
    i2.dispatchEvent(n2), t2.el && t2.el.remove(), t2.el = null;
  }
  transitionTo(t2 = 0, e2 = this.option("transition")) {
    if (!e2)
      return false;
    const { pages: i2, panzoom: n2 } = this;
    t2 = parseInt((t2 || 0).toString()) || 0;
    const s2 = this.getPageFromIndex(t2);
    if (!n2 || !i2[s2] || i2.length < 2 || i2[this.page].slides[0].dim < this.viewportDim)
      return false;
    const o2 = t2 > this.page ? 1 : -1, a2 = this.pages[s2].pos * (this.isRTL ? 1 : -1);
    if (this.page === s2 && v(a2, 1e3) === v(n2.target[this.axis], 1e3))
      return false;
    this.clearTransitions();
    const r2 = n2.isResting;
    R(this.container, this.cn("inTransition"));
    const l2 = this.pages[this.page].slides[0], c2 = this.pages[s2].slides[0];
    this.inTransition.add(c2.index), this.createSlideEl(c2);
    let h2 = l2.el, d2 = c2.el;
    r2 || "slide" === e2 || (e2 = "fadeFast", h2 = null);
    const u2 = this.isRTL ? "next" : "prev", p2 = this.isRTL ? "prev" : "next";
    return h2 && (this.inTransition.add(l2.index), l2.transition = e2, h2.addEventListener("animationend", this.onAnimationEnd), h2.classList.add(`f-${e2}Out`, `to-${o2 > 0 ? p2 : u2}`)), d2 && (c2.transition = e2, d2.addEventListener("animationend", this.onAnimationEnd), d2.classList.add(`f-${e2}In`, `from-${o2 > 0 ? u2 : p2}`)), n2.panTo({ x: this.isHorizontal ? a2 : 0, y: this.isHorizontal ? 0 : a2, friction: 0 }), this.onChange(s2), true;
  }
  manageSlideVisiblity() {
    const t2 = /* @__PURE__ */ new Set(), e2 = /* @__PURE__ */ new Set(), i2 = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
    for (const n2 of this.slides)
      i2.has(n2) ? t2.add(n2) : e2.add(n2);
    for (const e3 of this.inTransition)
      t2.add(this.slides[e3]);
    for (const e3 of t2)
      this.createSlideEl(e3), this.lazyLoadSlide(e3);
    for (const i3 of e2)
      t2.has(i3) || this.removeSlideEl(i3);
    this.markSelectedSlides(), this.repositionSlides();
  }
  markSelectedSlides() {
    if (!this.pages[this.page] || !this.pages[this.page].slides)
      return;
    const t2 = "aria-hidden";
    let e2 = this.cn("isSelected");
    if (e2)
      for (const i2 of this.slides)
        i2.el && (i2.el.dataset.index = `${i2.index}`, this.pages[this.page].slides.includes(i2) ? (i2.el.classList.contains(e2) || (R(i2.el, e2), this.emit("selectSlide", i2)), i2.el.removeAttribute(t2)) : (i2.el.classList.contains(e2) && (z(i2.el, e2), this.emit("unselectSlide", i2)), i2.el.setAttribute(t2, "true")));
  }
  flipInfiniteTrack() {
    const t2 = this.panzoom;
    if (!t2 || !this.isInfinite)
      return;
    const e2 = "x" === this.option("axis") ? "e" : "f", { viewportDim: i2, contentDim: n2 } = this;
    let s2 = t2.current[e2], o2 = t2.target[e2] - s2, a2 = 0, r2 = 0.5 * i2, l2 = n2;
    this.isRTL && this.isHorizontal ? (s2 < -r2 && (a2 = -1, s2 += l2), s2 > l2 - r2 && (a2 = 1, s2 -= l2)) : (s2 > r2 && (a2 = 1, s2 -= l2), s2 < -l2 + r2 && (a2 = -1, s2 += l2)), a2 && (t2.current[e2] = s2, t2.target[e2] = s2 + o2);
  }
  lazyLoadSlide(t2) {
    const e2 = this, n2 = t2 && t2.el;
    if (!n2)
      return;
    const s2 = /* @__PURE__ */ new Set();
    n2.querySelectorAll("[data-lazy-srcset]").forEach((t3) => {
      t3 instanceof HTMLImageElement && s2.add(t3);
    }), n2.querySelectorAll("[data-lazy-src]").forEach((t3) => {
      t3 instanceof HTMLImageElement ? s2.add(t3) : L(t3) && (t3.style.backgroundImage = `url('${t3.dataset.lazySrc || ""}')`);
    });
    const o2 = (t3, i2, n3) => {
      n3 && (n3.remove(), n3 = null), i2.complete && (i2.style.display = ""), this.option("adaptiveHeight") && t3.el && this.pages[this.page].slides.indexOf(t3) > -1 && e2.setViewportHeight();
    };
    for (const e3 of s2) {
      let n3 = null;
      e3.src = e3.dataset.lazySrcset || e3.dataset.lazySrc || "", delete e3.dataset.lazySrc, delete e3.dataset.lazySrcset, e3.style.display = "none", e3.addEventListener("error", () => {
        o2(t2, e3, n3);
      }), e3.addEventListener("load", () => {
        o2(t2, e3, n3);
      }), setTimeout(() => {
        e3.parentNode && t2.el && (e3.complete ? o2(t2, e3, n3) : (n3 = i(a), e3.parentNode.insertBefore(n3, e3)));
      }, 300);
    }
    let r2 = n2.dataset.lazySrc;
    r2 && r2.length && (n2.style.backgroundImage = `url('${r2}')`);
  }
  clearTransitions() {
    this.inTransition.clear(), z(this.container, this.cn("inTransition"));
    const t2 = ["to-prev", "to-next", "from-prev", "from-next"];
    for (const e2 of this.slides) {
      const i2 = e2.el;
      if (i2) {
        i2.removeEventListener("animationend", this.onAnimationEnd), i2.classList.remove(...t2);
        const n2 = e2.transition;
        n2 && i2.classList.remove(`f-${n2}Out`, `f-${n2}In`);
      }
    }
    this.manageSlideVisiblity();
  }
  onAnimationEnd(t2) {
    const e2 = t2.target, i2 = e2 ? parseInt(e2.dataset.index || "", 10) || 0 : -1, n2 = this.slides[i2], s2 = t2.animationName;
    if (!e2 || !n2 || !s2)
      return;
    const o2 = !!this.inTransition.has(i2) && n2.transition;
    o2 && s2.substring(0, o2.length + 2) === `f-${o2}` && this.inTransition.delete(i2), this.inTransition.size || this.clearTransitions(), i2 === this.page && this.emit("settle");
  }
  onDecel(t2, e2 = 0, i2 = 0, n2 = 0, s2 = 0) {
    const o2 = this.isRTL, a2 = this.isHorizontal, r2 = this.axis, l2 = this.pages.length, c2 = Math.abs(Math.atan2(i2, e2) / (Math.PI / 180));
    let h2 = 0;
    if (h2 = c2 > 45 && c2 < 135 ? a2 ? 0 : i2 : a2 ? e2 : 0, !l2)
      return;
    const d2 = this.option("dragFree");
    let u2 = this.page;
    const p2 = t2.target[r2] * (this.isRTL && a2 ? 1 : -1), { pageIndex: m2 } = this.getPageFromPosition(p2), f2 = t2.current[r2] * (o2 && a2 ? 1 : -1);
    let { page: g2 } = this.getPageFromPosition(f2);
    d2 ? this.onChange(m2) : (Math.abs(h2) > 5 ? (Math.max(Math.abs(n2), Math.abs(s2)) > this.pages[u2].slides[0].dim && (console.log(`yes? targetPage: ${m2}; currentPage: ${g2}`), u2 = g2), u2 = o2 && a2 ? h2 < 0 ? u2 - 1 : u2 + 1 : h2 < 0 ? u2 + 1 : u2 - 1) : u2 = g2, this.slideTo(u2, { transition: false, friction: t2.option("decelFriction") }));
  }
  onClick(t2) {
    const e2 = t2.target, i2 = e2 && L(e2) ? e2.dataset : null;
    let n2, s2;
    i2 && (void 0 !== i2.carouselPage ? (s2 = "slideTo", n2 = i2.carouselPage) : void 0 !== i2.carouselNext ? s2 = "slideNext" : void 0 !== i2.carouselPrev && (s2 = "slidePrev")), s2 ? (t2.preventDefault(), t2.stopPropagation(), e2 && !e2.hasAttribute("disabled") && this[s2](n2)) : this.emit("click", t2);
  }
  onSlideTo(t2) {
    const e2 = t2.detail || 0;
    this.slideTo(this.getPageForSlide(e2), { friction: 0 });
  }
  onChange(t2, e2 = 0) {
    const i2 = this.page;
    this.prevPage = i2, this.page = t2, this.option("adaptiveHeight") && this.setViewportHeight(), t2 !== i2 && (this.markSelectedSlides(), this.emit("change", t2, i2, e2));
  }
  onRefresh(t2, e2 = "") {
    let i2 = this.contentDim, n2 = this.viewportDim;
    this.updateMetrics(), this.contentDim === i2 && this.viewportDim === n2 || this.slideTo(this.page, { friction: 0, transition: false });
  }
  onResize() {
    this.option("breakpoints") && this.processOptions();
  }
  onBeforeTransform() {
    this.flipInfiniteTrack(), this.manageSlideVisiblity();
  }
  onEndAnimation() {
    this.emit("settle");
  }
  reInit(t2 = null, e2 = null) {
    this.destroy(), this.state = ot.Init, this.userOptions = t2 || this.userOptions, this.userPlugins = e2 || this.userPlugins, this.processOptions();
  }
  slideTo(t2 = 0, { friction: e2 = this.option("friction"), transition: i2 = this.option("transition") } = {}) {
    if (this.state === ot.Destroy)
      return;
    const n2 = this.panzoom, s2 = this.pages.length;
    if (!n2 || !s2)
      return;
    if (this.transitionTo(t2, i2))
      return;
    const o2 = this.axis, a2 = this.getPageFromIndex(t2);
    let r2 = this.pages[a2].pos, l2 = 0;
    if (this.isInfinite) {
      const t3 = n2.current[o2] * (this.isRTL && this.isHorizontal ? 1 : -1), e3 = this.contentDim, i3 = r2 + e3, s3 = r2 - e3;
      Math.abs(t3 - i3) < Math.abs(t3 - r2) && (r2 = i3, l2 = 1), Math.abs(t3 - s3) < Math.abs(t3 - r2) && (r2 = s3, l2 = -1);
    }
    r2 *= this.isRTL && this.isHorizontal ? 1 : -1, Math.abs(n2.target[o2] - r2) < 0.1 || (n2.panTo({ x: this.isHorizontal ? r2 : 0, y: this.isHorizontal ? 0 : r2, friction: e2 }), this.onChange(a2, l2));
  }
  slideToClosest(t2) {
    if (this.panzoom) {
      const { pageIndex: e2 } = this.getPageFromPosition(this.panzoom.current[this.isHorizontal ? "e" : "f"]);
      this.slideTo(e2, t2);
    }
  }
  slideNext() {
    this.slideTo(this.page + 1);
  }
  slidePrev() {
    this.slideTo(this.page - 1);
  }
  prependSlide(t2) {
    var e2, i2;
    let n2 = Array.isArray(t2) ? t2 : [t2];
    for (const t3 of n2.reverse())
      this.slides.unshift(at(t3));
    for (let t3 = 0; t3 < this.slides.length; t3++)
      this.slides[t3].index = t3;
    const s2 = (null === (e2 = this.pages[this.page]) || void 0 === e2 ? void 0 : e2.pos) || 0;
    this.page += n2.length, this.updateMetrics();
    const o2 = (null === (i2 = this.pages[this.page]) || void 0 === i2 ? void 0 : i2.pos) || 0;
    if (this.panzoom) {
      const t3 = this.isRTL ? s2 - o2 : o2 - s2;
      this.panzoom.target.e -= t3, this.panzoom.current.e -= t3, this.panzoom.requestTick();
    }
  }
  appendSlide(t2) {
    let e2 = Array.isArray(t2) ? t2 : [t2];
    for (const t3 of e2) {
      const e3 = at(t3);
      e3.index = this.slides.length, this.slides.push(e3), this.emit("initSlide", t3, this.slides.length);
    }
    this.updateMetrics();
  }
  removeSlide(t2) {
    const e2 = this.slides.length;
    t2 = (t2 % e2 + e2) % e2, this.removeSlideEl(this.slides[t2], true), this.slides.splice(t2, 1);
    for (let t3 = 0; t3 < this.slides.length; t3++)
      this.slides[t3].index = t3;
    this.updateMetrics(), this.slideTo(this.page, { friction: 0, transition: false });
  }
  updateMetrics() {
    const t2 = this.panzoom;
    if (!this.track)
      return;
    const e2 = "e" === this.axis ? "width" : "height";
    let i2, n2 = this.pages.length, s2 = 0;
    for (const [t3, e3] of this.slides.entries()) {
      let n3 = 0, o3 = 0;
      !e3.el && i2 ? (n3 = i2.dim, o3 = i2.gap) : ({ dim: n3, gap: o3 } = this.getSlideMetrics(e3), i2 = e3), n3 = v(n3, 1e3), o3 = v(o3, 1e3), e3.dim = n3, e3.gap = o3, e3.pos = s2, s2 += n3, (this.isInfinite || t3 < this.slides.length - 1) && (s2 += o3);
    }
    this.viewport && (this.viewportDim = v(this.viewport.getBoundingClientRect()[e2], 1e3));
    const o2 = this.contentDim;
    this.contentDim = s2, t2 && (t2.contentRect[e2] = s2, t2.contentRect["e" === this.axis ? "fullWidth" : "fullHeight"] = s2), this.pages = this.createPages(), this.pages = this.processPages(), this.state === ot.Init && this.setInitialPage(), this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), t2 && n2 === this.pages.length && s2 !== o2 && (t2.target[this.axis] = -1 * this.pages[this.page].pos, t2.current[this.axis] = -1 * this.pages[this.page].pos, t2.stop()), this.manageSlideVisiblity(), this.emit("refresh");
  }
  setViewportHeight() {
    const { page: t2, pages: e2, viewport: i2, isHorizontal: n2 } = this;
    if (!i2 || !e2[t2])
      return;
    let s2 = 0;
    n2 && this.track && (this.track.style.height = "auto", e2[t2].slides.forEach((t3) => {
      t3.el && (s2 = Math.max(s2, t3.el.offsetHeight));
    })), i2.style.height = s2 ? `${s2}px` : "";
  }
  getPageForSlide(t2) {
    for (const e2 of this.pages)
      for (const i2 of e2.slides)
        if (i2.index === t2)
          return e2.index;
    return -1;
  }
  getVisibleSlides(t2 = 0) {
    var e2;
    const i2 = /* @__PURE__ */ new Set();
    let { contentDim: n2, viewportDim: s2, pages: o2, page: a2 } = this;
    n2 = n2 + (null === (e2 = this.slides[this.slides.length - 1]) || void 0 === e2 ? void 0 : e2.gap) || 0;
    let r2 = 0;
    r2 = this.panzoom ? -1 * this.panzoom.current[this.axis] : o2[a2] && o2[a2].pos || 0, this.isInfinite && (r2 -= Math.floor(r2 / n2) * n2), this.isRTL && this.isHorizontal && (r2 *= -1);
    const l2 = r2 - s2 * t2, c2 = r2 + s2 * (t2 + 1), h2 = this.isInfinite ? [-1, 0, 1] : [0];
    for (const t3 of this.slides)
      for (const e3 of h2) {
        const s3 = t3.pos + e3 * n2, o3 = t3.pos + t3.dim + t3.gap + e3 * n2;
        s3 < c2 && o3 > l2 && i2.add(t3);
      }
    return i2;
  }
  getPageFromPosition(t2) {
    const { viewportDim: e2, contentDim: i2 } = this, n2 = this.pages.length, s2 = this.slides.length, o2 = this.slides[s2 - 1];
    let a2 = 0, r2 = 0, l2 = 0;
    const c2 = this.option("center");
    c2 && (t2 += 0.5 * e2), this.isInfinite || (t2 = Math.max(this.slides[0].pos, Math.min(t2, o2.pos)));
    const h2 = i2 + o2.gap;
    l2 = Math.floor(t2 / h2) || 0, t2 -= l2 * h2;
    let d2 = o2, u2 = this.slides.find((e3) => {
      const i3 = t2 + (d2 && !c2 ? 0.5 * d2.dim : 0);
      return d2 = e3, e3.pos <= i3 && e3.pos + e3.dim + e3.gap > i3;
    });
    return u2 || (u2 = o2), r2 = this.getPageForSlide(u2.index), a2 = r2 + l2 * n2, { page: a2, pageIndex: r2, interval: l2 };
  }
  destroy() {
    if ([ot.Destroy].includes(this.state))
      return;
    this.state = ot.Destroy;
    const { container: t2, viewport: e2, track: i2, slides: n2, panzoom: s2 } = this, o2 = this.option("classes");
    t2.removeEventListener("click", this.onClick, { passive: false, capture: false }), t2.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), s2 && (s2.destroy(), this.panzoom = null), n2 && n2.forEach((t3) => {
      this.removeSlideEl(t3);
    }), this.detachPlugins(), this.track = null, this.viewport = null, this.page = 0, e2 && i2 && e2.replaceWith(...i2.childNodes);
    for (const [e3, i3] of Object.entries(o2))
      "container" !== e3 && i3 && t2.classList.remove(i3);
    this.slides = [];
    const a2 = this.events.get("ready");
    this.events = /* @__PURE__ */ new Map(), a2 && this.events.set("ready", a2);
  }
};
Object.defineProperty(pt, "Panzoom", { enumerable: true, configurable: true, writable: true, value: F }), Object.defineProperty(pt, "defaults", { enumerable: true, configurable: true, writable: true, value: st }), Object.defineProperty(pt, "Plugins", { enumerable: true, configurable: true, writable: true, value: ut });
var mt = null;
var ft = null;
var gt = /* @__PURE__ */ new Map();
var bt = 0;
var vt = class extends p {
  get isIdle() {
    return this.idle;
  }
  get isCompact() {
    return this.option("compact");
  }
  constructor(t2 = [], e2 = {}, i2 = {}) {
    super(e2), Object.defineProperty(this, "userSlides", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "userPlugins", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "idle", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "idleTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "clickTimer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prevWheelTime", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "ignoreFocusChange", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "state", { enumerable: true, configurable: true, writable: true, value: c.Init }), Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "container", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "footer", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "carousel", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "lastFocus", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "prevMouseMoveEvent", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fsAPI", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.fsAPI = (() => {
      let t3, e3 = "", i3 = "", n2 = "";
      return document.fullscreenEnabled ? (e3 = "requestFullscreen", i3 = "exitFullscreen", n2 = "fullscreenElement") : document.webkitFullscreenEnabled && (e3 = "webkitRequestFullscreen", i3 = "webkitExitFullscreen", n2 = "webkitFullscreenElement"), e3 && (t3 = { request: function(t4) {
        return "webkitRequestFullscreen" === e3 ? t4[e3](Element.ALLOW_KEYBOARD_INPUT) : t4[e3]();
      }, exit: function() {
        return document[n2] && document[i3]();
      }, isFullscreen: function() {
        return document[n2];
      } }), t3;
    })(), this.id = e2.id || ++bt, gt.set(this.id, this), this.userSlides = t2, this.userPlugins = i2, queueMicrotask(() => {
      this.init();
    });
  }
  init() {
    this.state = c.Init, this.attachPlugins(Object.assign(Object.assign({}, vt.Plugins), this.userPlugins)), this.emit("init"), true === this.option("hideScrollbar") && (() => {
      if (!n)
        return;
      if (document.body.classList.contains("compensate-for-scrollbar"))
        return;
      const t3 = window.innerWidth - document.documentElement.getBoundingClientRect().width;
      t3 > 1 && (document.documentElement.style.setProperty("--fancybox-scrollbar-compensate", `${t3}px`), document.body.classList.add("compensate-for-scrollbar"));
    })(), this.initLayout();
    const t2 = () => {
      this.initCarousel(this.userSlides), this.state = c.Ready, this.attachEvents(), this.emit("ready"), setTimeout(() => {
        this.container && this.container.setAttribute("aria-hidden", "false");
      }, 16);
    };
    this.option("Fullscreen.autoStart") && this.fsAPI && !this.fsAPI.isFullscreen() ? this.fsAPI.request(this.container).then(() => t2()).catch(() => t2()) : t2();
  }
  initLayout() {
    const t2 = this.option("parentEl") || document.body, e2 = i(this.localize(this.option("tpl.main") || ""));
    e2 && (e2.setAttribute("id", `fancybox-${this.id}`), e2.setAttribute("aria-label", this.localize("{{MODAL}}")), e2.classList.toggle("is-compact", this.isCompact), R(e2, this.option("mainClass") || ""), this.container = e2, this.footer = e2.querySelector(".fancybox__footer"), t2.appendChild(e2), document.documentElement.classList.add("with-fancybox"), mt && ft || (mt = document.createElement("button"), mt.classList.add("fancybox-focus-guard"), mt.setAttribute("aria-hidden", "true"), mt.setAttribute("aria-label", "Focus guard"), mt.setAttribute("type", "button"), ft = mt.cloneNode(), document.body.prepend(mt), document.body.append(ft)), this.option("animated") && (e2.classList.add("is-animated"), setTimeout(() => {
      this.isClosing() || e2.classList.remove("is-animated");
    }, 350)), this.emit("initLayout"));
  }
  initCarousel(t2) {
    const i2 = this.container;
    if (!i2)
      return;
    const n2 = i2.querySelector(".fancybox__carousel");
    if (!n2)
      return;
    const s2 = this.carousel = new pt(n2, e({}, { slides: t2, transition: "fade", Panzoom: { lockAxis: this.option("dragToClose") ? "xy" : "x", infinite: !!this.option("dragToClose") && "y" }, Dots: false, Navigation: { classes: { container: "fancybox__nav", button: "f-button", isNext: "is-next", isPrev: "is-prev" } }, initialPage: this.option("startIndex"), l10n: this.option("l10n") }, this.option("Carousel") || {}));
    s2.on("*", (t3, e2, ...i3) => {
      this.emit(`Carousel.${e2}`, t3, ...i3);
    }), s2.on(["ready", "change"], () => {
      this.manageCaption(this.getSlide());
    }), s2.on("removeSlide", (t3, e2) => {
      e2.closeBtnEl && e2.closeBtnEl.remove(), e2.closeBtnEl = void 0, e2.captionEl && e2.captionEl.remove(), e2.captionEl = void 0, e2.spinnerEl && e2.spinnerEl.remove(), e2.spinnerEl = void 0, e2.state = void 0;
    }), s2.on("Panzoom.touchStart", () => {
      this.isCompact || this.endIdle();
    }), s2.on("settle", () => {
      this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && this.checkFocus();
    }), this.option("dragToClose") && (s2.on("Panzoom.afterTransform", (t3, e2) => {
      const i3 = this.container;
      if (i3) {
        const t4 = Math.abs(e2.current.f), n3 = t4 < 1 ? "" : Math.max(0.5, Math.min(1, 1 - t4 / e2.contentRect.fitHeight * 1.5));
        i3.style.setProperty("--fancybox-ts", n3 ? "0s" : ""), i3.style.setProperty("--fancybox-opacity", n3 + "");
      }
    }), s2.on("Panzoom.touchEnd", (t3, e2, i3) => {
      var n3;
      if (e2.isMobile && document.activeElement && -1 !== ["TEXTAREA", "INPUT", "SELECT"].indexOf(null === (n3 = document.activeElement) || void 0 === n3 ? void 0 : n3.nodeName))
        return;
      const s3 = this.getSlide();
      if (s3 && s3.el && s3.el.scrollHeight > s3.el.clientHeight)
        return;
      const o2 = Math.abs(e2.dragOffset.y);
      "y" === e2.lockedAxis && (o2 >= 200 || o2 >= 50 && e2.dragOffset.time < 300) && (i3 && i3.cancelable && i3.preventDefault(), this.close(i3, "f-throwOut" + (e2.current.f < 0 ? "Up" : "Down")));
    })), s2.on(["change"], (t3) => {
      var e2;
      let i3 = null === (e2 = this.getSlide()) || void 0 === e2 ? void 0 : e2.triggerEl;
      if (i3) {
        const e3 = new CustomEvent("slideTo", { bubbles: true, cancelable: true, detail: t3.page });
        i3.dispatchEvent(e3);
      }
    }), s2.on(["refresh", "change"], (t3) => {
      const e2 = this.container;
      if (!e2)
        return;
      for (const i4 of e2.querySelectorAll("[data-fancybox-current-index]"))
        i4.innerHTML = t3.page + 1;
      for (const i4 of e2.querySelectorAll("[data-fancybox-count]"))
        i4.innerHTML = t3.pages.length;
      if (!t3.isInfinite) {
        for (const i4 of e2.querySelectorAll("[data-fancybox-next]"))
          t3.page < t3.pages.length - 1 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
        for (const i4 of e2.querySelectorAll("[data-fancybox-prev]"))
          t3.page > 0 ? (i4.removeAttribute("disabled"), i4.removeAttribute("tabindex")) : (i4.setAttribute("disabled", ""), i4.setAttribute("tabindex", "-1"));
      }
      const i3 = this.getSlide();
      let n3 = (null == i3 ? void 0 : i3.downloadSrc) || "";
      n3 || !i3 || "image" !== i3.type || i3.error || "string" != typeof i3.src || (n3 = i3.src);
      for (const t4 of e2.querySelectorAll("[data-fancybox-download]"))
        n3 ? (t4.removeAttribute("disabled"), t4.removeAttribute("tabindex"), t4.setAttribute("href", n3), t4.setAttribute("download", n3), t4.setAttribute("target", "_blank")) : (t4.setAttribute("disabled", ""), t4.setAttribute("tabindex", "-1"), t4.removeAttribute("href"), t4.removeAttribute("download"));
    }), this.emit("initCarousel");
  }
  attachEvents() {
    const t2 = this.container;
    t2 && (document.addEventListener("keydown", this.onKeydown, { passive: false, capture: true }), t2.addEventListener("wheel", this.onWheel, { passive: false, capture: false }), t2.addEventListener("click", this.onClick, { passive: false, capture: false }), document.addEventListener("mousemove", this.onMousemove), window.addEventListener("resize", this.onResize), this.option("trapFocus") && document.addEventListener("focus", this.onFocus, true), document.addEventListener("visibilitychange", this.onVisibilityChange, false));
  }
  detachEvents() {
    const t2 = this.container;
    t2 && (document.removeEventListener("keydown", this.onKeydown, { passive: false, capture: true }), t2.removeEventListener("wheel", this.onWheel, { passive: false, capture: false }), t2.removeEventListener("click", this.onClick, { passive: false, capture: false }), document.removeEventListener("mousemove", this.onMousemove), window.removeEventListener("resize", this.onResize), document.removeEventListener("visibilitychange", this.onVisibilityChange, false), document.removeEventListener("focus", this.onFocus, true));
  }
  onClick(t2) {
    var e2, i2;
    if (this.isClosing())
      return;
    !this.isCompact && this.option("idle") && this.resetIdle();
    const n2 = t2.composedPath()[0];
    if (n2 === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.container))
      return;
    if (n2.closest(".f-spinner") || n2.closest("[data-fancybox-close]"))
      return t2.preventDefault(), void this.close(t2);
    if (n2.closest("[data-fancybox-prev]"))
      return t2.preventDefault(), void this.prev();
    if (n2.closest("[data-fancybox-next]"))
      return t2.preventDefault(), void this.next();
    if (this.isCompact && "image" === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.type))
      return void (this.clickTimer ? (clearTimeout(this.clickTimer), this.clickTimer = null) : this.clickTimer = setTimeout(() => {
        this.toggleIdle(), this.clickTimer = null;
      }, 350));
    if (this.emit("click", t2), t2.defaultPrevented)
      return;
    let s2 = false;
    const a2 = document.activeElement;
    if (n2.closest(".fancybox__content")) {
      if (a2) {
        if (a2.closest("[contenteditable]"))
          return;
        n2.matches(o) || a2.blur();
      }
      if ((r2 = window.getSelection()) && "Range" === r2.type)
        return;
      s2 = this.option("contentClick");
    } else
      n2.closest(".fancybox__carousel") && !n2.matches(o) && (s2 = this.option("backdropClick"));
    var r2;
    "close" === s2 ? (t2.preventDefault(), this.close(t2)) : "next" === s2 ? (t2.preventDefault(), this.next()) : "prev" === s2 && (t2.preventDefault(), this.prev());
  }
  onWheel(t2) {
    const e2 = t2.wheelDeltaY ? t2.wheelDeltaY === -3 * t2.deltaY : 0 === t2.deltaMode, i2 = Date.now();
    if (this.prevWheelTime && i2 - this.prevWheelTime < (e2 ? 600 : 300))
      return void t2.preventDefault();
    if (this.prevWheelTime = i2, this.emit("wheel", t2), t2.defaultPrevented)
      return;
    const n2 = this.option("wheel", t2);
    if ("close" === n2)
      t2.preventDefault(), this.close(t2);
    else if ("slide" === n2) {
      t2.preventDefault();
      this[Math.max(-1, Math.min(1, -t2.deltaY || -t2.deltaX || -t2.detail)) > 0 ? "prev" : "next"]();
    }
  }
  onKeydown(t2) {
    if (!this.isTopmost())
      return;
    this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
    const e2 = t2.key, i2 = this.option("keyboard");
    if (!i2 || t2.ctrlKey || t2.altKey || t2.shiftKey)
      return;
    const n2 = t2.composedPath()[0], s2 = document.activeElement && document.activeElement.classList, o2 = s2 && s2.contains("f-button") || n2.dataset.carouselPage || n2.dataset.carouselIndex;
    if ("Escape" !== e2 && !o2 && L(n2)) {
      if (n2.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n2.nodeName))
        return;
    }
    this.emit("keydown", e2, t2);
    const a2 = i2[e2];
    "function" == typeof this[a2] && (t2.preventDefault(), this[a2]());
  }
  onResize() {
    const t2 = this.container;
    if (!t2)
      return;
    const e2 = this.isCompact;
    t2.classList.toggle("is-compact", e2), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), this.emit("resize");
  }
  onFocus(t2) {
    this.isTopmost() && this.focus(t2);
  }
  onMousemove(t2) {
    this.prevMouseMoveEvent = t2, !this.isCompact && this.option("idle") && this.resetIdle();
  }
  onVisibilityChange() {
    "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
  }
  manageCloseBtn(t2) {
    const e2 = this.optionFor(t2, "closeButton") || false;
    if ("auto" === e2) {
      const t3 = this.plugins.Toolbar;
      if (t3 && t3.state === K.Ready)
        return;
    }
    if (!e2)
      return;
    if (!t2.contentEl || t2.closeBtnEl)
      return;
    const n2 = this.option("tpl.closeButton");
    if (n2) {
      const e3 = i(this.localize(n2));
      t2.closeBtnEl = t2.contentEl.appendChild(e3), t2.el && R(t2.el, "has-close-btn");
    }
  }
  manageCaption(t2) {
    var e2, i2, n2;
    const s2 = this.container;
    if (!s2)
      return;
    const o2 = this.isCompact || this.option("commonCaption"), a2 = !o2;
    if (this.caption && this.stop(this.caption), a2 && this.caption && (this.caption.remove(), this.caption = null), o2 && !this.caption)
      for (const t3 of (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.slides) || [])
        t3.captionEl && (t3.captionEl.remove(), t3.captionEl = void 0, null === (i2 = t3.el) || void 0 === i2 || i2.classList.remove("has-caption"), null === (n2 = t3.el) || void 0 === n2 || n2.removeAttribute("aria-labelledby"));
    if (t2 || (t2 = this.getSlide()), !t2 || o2 && !this.isCurrentSlide(t2))
      return;
    const r2 = t2.el;
    let l2 = this.optionFor(t2, "caption", "");
    if ("string" != typeof l2 || !l2.length)
      return void (o2 && this.caption && this.animate(this.caption, "f-fadeOut", () => {
        var t3;
        null === (t3 = this.caption) || void 0 === t3 || t3.remove(), this.caption = null;
      }));
    let c2 = null;
    if (a2) {
      if (c2 = t2.captionEl || null, r2 && !c2) {
        const e3 = `fancybox__caption_${this.id}_${t2.index}`;
        c2 = document.createElement("div"), c2.className = "fancybox__caption", c2.setAttribute("id", e3), t2.captionEl = r2.appendChild(c2), r2.classList.add("has-caption"), r2.setAttribute("aria-labelledby", e3);
      }
    } else {
      if (c2 = this.caption, c2 || (c2 = s2.querySelector(".fancybox__caption")), !c2) {
        c2 = document.createElement("div"), c2.dataset.fancyboxCaption = "", c2.className = "fancybox__caption", c2.innerHTML = l2;
        (this.footer || s2).prepend(c2);
      }
      s2.classList.add("has-caption"), this.caption = c2;
    }
    c2 && (c2.innerHTML = l2);
  }
  checkFocus() {
    var t2;
    const e2 = document.activeElement || null;
    e2 && (null === (t2 = this.container) || void 0 === t2 ? void 0 : t2.contains(e2)) || this.focus();
  }
  focus(t2) {
    var e2;
    if (this.ignoreFocusChange)
      return;
    const i2 = document.activeElement || null, a2 = (null == t2 ? void 0 : t2.target) || null, r2 = this.container, l2 = this.getSlide();
    if (!r2 || !(null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.viewport))
      return;
    const c2 = l2 && l2.state === h.Ready ? l2.el : null;
    if (!c2 || c2.contains(i2) || r2 === i2)
      return;
    t2 && t2.cancelable && t2.preventDefault(), this.ignoreFocusChange = true;
    const d2 = Array.from(r2.querySelectorAll(o));
    let u2 = [], p2 = r2;
    for (let t3 of d2) {
      const e3 = !t3.offsetParent || t3.closest('[aria-hidden="true"]'), i3 = c2 && c2.contains(t3), n2 = !this.carousel.viewport.contains(t3);
      t3 === r2 || (i3 || n2) && !e3 ? (u2.push(t3), void 0 !== t3.dataset.origTabindex && (t3.tabIndex = parseFloat(t3.dataset.origTabindex)), t3.removeAttribute("data-orig-tabindex"), t3.hasAttribute("autoFocus") && (p2 = t3)) : (t3.dataset.origTabindex = void 0 === t3.dataset.origTabindex ? t3.getAttribute("tabindex") || void 0 : t3.dataset.origTabindex, t3.tabIndex = -1);
    }
    let m2 = null;
    t2 ? (!a2 || u2.indexOf(a2) < 0) && (m2 = p2, u2.length && (i2 === ft ? m2 = u2[0] : this.lastFocus !== r2 && i2 !== mt || (m2 = u2[u2.length - 1]))) : this.option("autoFocus") && (m2 = p2), m2 && ((t3) => {
      if (t3 && n) {
        void 0 === s && document.createElement("div").focus({ get preventScroll() {
          return s = true, false;
        } });
        try {
          if (s)
            t3.focus({ preventScroll: true });
          else {
            const e3 = window.pageXOffset || document.body.scrollTop, i3 = window.pageYOffset || document.body.scrollLeft;
            t3.focus(), document.body.scrollTo({ top: e3, left: i3, behavior: "auto" });
          }
        } catch (t4) {
        }
      }
    })(m2), this.lastFocus = document.activeElement, this.ignoreFocusChange = false;
  }
  next() {
    const t2 = this.carousel;
    t2 && t2.pages.length > 1 && t2.slideNext();
  }
  prev() {
    const t2 = this.carousel;
    t2 && t2.pages.length > 1 && t2.slidePrev();
  }
  jumpTo(...t2) {
    this.carousel && this.carousel.slideTo(...t2);
  }
  isTopmost() {
    var t2;
    return (null === (t2 = vt.getInstance()) || void 0 === t2 ? void 0 : t2.id) == this.id;
  }
  animate(t2 = null, e2 = "", i2) {
    if (!t2 || !e2)
      return void (i2 && i2());
    this.stop(t2);
    const n2 = (s2) => {
      s2.target === t2 && t2.dataset.animationName && (t2.removeEventListener("animationend", n2), delete t2.dataset.animationName, i2 && i2(), t2.classList.remove(e2));
    };
    t2.dataset.animationName = e2, t2.addEventListener("animationend", n2), t2.classList.add(e2);
  }
  stop(t2) {
    t2 && t2.dispatchEvent(new CustomEvent("animationend", { bubbles: false, cancelable: true, currentTarget: t2 }));
  }
  setContent(t2, e2 = "", i2 = true) {
    if (this.isClosing())
      return;
    const n2 = t2.el;
    if (!n2)
      return;
    let s2 = null;
    if (L(e2))
      ["img", "iframe", "video", "audio"].includes(e2.nodeName.toLowerCase()) ? (s2 = document.createElement("div"), s2.appendChild(e2)) : s2 = e2;
    else {
      const t3 = document.createRange().createContextualFragment(e2);
      s2 = document.createElement("div"), s2.appendChild(t3);
    }
    s2 instanceof Element && t2.filter && !t2.error && (s2 = s2.querySelector(t2.filter)), s2 instanceof Element ? (s2.classList.add("fancybox__content"), t2.id && s2.setAttribute("id", t2.id), "none" !== s2.style.display && "none" !== getComputedStyle(s2).getPropertyValue("display") || (s2.style.display = t2.display || this.option("defaultDisplay") || "flex"), n2.classList.add(`has-${t2.error ? "error" : t2.type || "unknown"}`), n2.prepend(s2), t2.contentEl = s2, i2 && this.revealContent(t2), this.manageCloseBtn(t2), this.manageCaption(t2)) : this.setError(t2, "{{ELEMENT_NOT_FOUND}}");
  }
  revealContent(t2, e2) {
    const i2 = t2.el, n2 = t2.contentEl;
    i2 && n2 && (this.emit("reveal", t2), this.hideLoading(t2), t2.state = h.Opening, (e2 = this.isOpeningSlide(t2) ? void 0 === e2 ? this.optionFor(t2, "showClass") : e2 : "f-fadeIn") ? this.animate(n2, e2, () => {
      this.done(t2);
    }) : this.done(t2));
  }
  done(t2) {
    var e2;
    this.isClosing() || (t2.state = h.Ready, this.emit("done", t2), null === (e2 = t2.el) || void 0 === e2 || e2.classList.add("is-done"), this.isCurrentSlide(t2) && this.option("autoFocus") && queueMicrotask(() => {
      var t3;
      if (this.option("autoFocus")) {
        const e3 = document.activeElement || null;
        e3 && (null === (t3 = this.container) || void 0 === t3 ? void 0 : t3.contains(e3)) || this.focus();
      }
    }), this.isOpeningSlide(t2) && !this.isCompact && this.option("idle") && this.setIdle());
  }
  isCurrentSlide(t2) {
    const e2 = this.getSlide();
    return !(!t2 || !e2) && e2.index === t2.index;
  }
  isOpeningSlide(t2) {
    var e2, i2;
    return null === (null === (e2 = this.carousel) || void 0 === e2 ? void 0 : e2.prevPage) && t2.index === (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.index);
  }
  showLoading(t2) {
    t2.state = h.Loading;
    const e2 = t2.el;
    if (!e2)
      return;
    e2.classList.add("is-loading"), this.emit("loading", t2), t2.spinnerEl || setTimeout(() => {
      if (!this.isClosing() && !t2.spinnerEl && t2.state === h.Loading) {
        let n2 = i(a);
        t2.spinnerEl = n2, e2.prepend(n2), this.animate(n2, "f-fadeIn");
      }
    }, 250);
  }
  hideLoading(t2) {
    const e2 = t2.el;
    if (!e2)
      return;
    const i2 = t2.spinnerEl;
    this.isClosing() ? null == i2 || i2.remove() : (e2.classList.remove("is-loading"), i2 && this.animate(i2, "f-fadeOut", () => {
      i2.remove();
    }), t2.state === h.Loading && (this.emit("loaded", t2), t2.state = h.Ready));
  }
  setError(t2, e2) {
    if (this.isClosing())
      return;
    this.emit("error"), t2.error = e2, this.hideLoading(t2), this.clearContent(t2);
    const i2 = document.createElement("div");
    i2.classList.add("fancybox-error"), i2.innerHTML = this.localize(e2 || "<p>{{ERROR}}</p>"), this.setContent(t2, i2);
  }
  clearContent(t2) {
    var e2;
    null === (e2 = this.carousel) || void 0 === e2 || e2.emit("removeSlide", t2), t2.contentEl && (t2.contentEl.remove(), t2.contentEl = void 0), t2.closeBtnEl && (t2.closeBtnEl.remove(), t2.closeBtnEl = void 0);
    const i2 = t2.el;
    i2 && (z(i2, "is-loading"), z(i2, "has-error"), z(i2, "has-unknown"), z(i2, `has-${t2.type || "unknown"}`));
  }
  getSlide() {
    var t2;
    const e2 = this.carousel;
    return (null === (t2 = null == e2 ? void 0 : e2.pages[null == e2 ? void 0 : e2.page]) || void 0 === t2 ? void 0 : t2.slides[0]) || void 0;
  }
  close(t2, e2) {
    if (this.isClosing())
      return;
    const i2 = new Event("shouldClose", { bubbles: true, cancelable: true });
    if (this.emit("shouldClose", i2, t2), i2.defaultPrevented)
      return;
    t2 && t2.cancelable && (t2.preventDefault(), t2.stopPropagation());
    const n2 = this.fsAPI, s2 = () => {
      this.proceedClose(t2, e2);
    };
    n2 && n2.isFullscreen() ? Promise.resolve(n2.exit()).then(() => s2()) : s2();
  }
  clearIdle() {
    this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
  }
  setIdle(t2 = false) {
    const e2 = () => {
      var t3;
      this.clearIdle(), this.idle = true, null === (t3 = this.container) || void 0 === t3 || t3.classList.add("is-idle"), this.emit("setIdle");
    };
    if (this.clearIdle(), !this.isClosing())
      if (t2)
        e2();
      else {
        const t3 = this.option("idle");
        t3 && (this.idleTimer = setTimeout(e2, t3));
      }
  }
  endIdle() {
    var t2;
    this.clearIdle(), this.idle && !this.isClosing() && (this.idle = false, null === (t2 = this.container) || void 0 === t2 || t2.classList.remove("is-idle"), this.emit("endIdle"));
  }
  resetIdle() {
    this.endIdle(), this.setIdle();
  }
  toggleIdle() {
    this.idle ? this.endIdle() : this.setIdle(true);
  }
  toggleFullscreen() {
    const t2 = this.fsAPI;
    t2 && (t2.isFullscreen() ? t2.exit() : this.container && t2.request(this.container));
  }
  isClosing() {
    return [c.Closing, c.CustomClosing, c.Destroy].includes(this.state);
  }
  proceedClose(t2, e2) {
    var i2, n2;
    this.state = c.Closing, this.clearIdle(), this.detachEvents();
    const s2 = this.container, o2 = this.carousel, a2 = this.getSlide();
    if (a2) {
      const t3 = this.option("placeFocusBack") ? (null === (i2 = this.getSlide()) || void 0 === i2 ? void 0 : i2.triggerEl) || this.option("trigger") : null;
      t3 && t3.focus();
    }
    if (s2 && (R(s2, "is-closing"), s2.setAttribute("aria-hidden", "true"), this.option("animated") && R(s2, "is-animated"), s2.style.pointerEvents = "none"), o2) {
      o2.clearTransitions(), null === (n2 = o2.panzoom) || void 0 === n2 || n2.destroy();
      for (const t3 of o2.slides) {
        t3.state = h.Closing, this.hideLoading(t3);
        const e3 = t3.contentEl;
        e3 && this.stop(e3);
        const i3 = null == t3 ? void 0 : t3.panzoom;
        i3 && (i3.stop(), i3.detachEvents(), i3.detachObserver()), this.isCurrentSlide(t3) || o2.emit("removeSlide", t3);
      }
    }
    this.emit("close", t2), this.state !== c.CustomClosing ? (void 0 === e2 && a2 && (e2 = this.optionFor(a2, "hideClass")), e2 && a2 ? (this.animate(a2.contentEl, e2, () => {
      o2 && o2.emit("removeSlide", a2);
    }), setTimeout(() => {
      this.destroy();
    }, 350)) : this.destroy()) : setTimeout(() => {
      this.destroy();
    }, 350);
  }
  destroy() {
    var t2;
    if (this.state === c.Destroy)
      return;
    this.state = c.Destroy, null === (t2 = this.carousel) || void 0 === t2 || t2.destroy();
    const e2 = this.container;
    e2 && e2.remove(), gt.delete(this.id);
    const i2 = vt.getInstance();
    i2 ? i2.focus() : (mt && (mt.remove(), mt = null), ft && (ft.remove(), ft = null), document.documentElement.classList.remove("with-fancybox"), n && (document.documentElement.style.setProperty("--fancybox-scrollbar-compensate", ""), document.body.classList.remove("compensate-for-scrollbar")));
  }
  static bind(t2, e2, i2) {
    if (!n)
      return;
    let s2, o2 = "", a2 = {};
    if ("string" == typeof t2 ? (s2 = document.body, o2 = t2, "object" == typeof e2 && (a2 = e2 || {})) : (s2 = t2, "string" == typeof e2 && (o2 = e2), "object" == typeof i2 && (a2 = i2 || {})), !s2)
      return;
    o2 = o2 || "[data-fancybox]";
    const r2 = vt.openers.get(s2) || /* @__PURE__ */ new Map();
    r2.set(o2, a2), vt.openers.set(s2, r2), 1 === r2.size && s2.addEventListener("click", vt.fromEvent);
  }
  static unbind(t2, e2) {
    let i2, n2 = "";
    if ("string" == typeof t2 ? (i2 = document.body, n2 = t2) : (i2 = t2, "string" == typeof e2 && (n2 = e2)), !i2)
      return;
    const s2 = vt.openers.get(i2);
    s2 && n2 && s2.delete(n2), n2 && s2 || (vt.openers.delete(i2), i2.removeEventListener("click", vt.fromEvent));
  }
  static destroy() {
    let t2;
    for (; t2 = vt.getInstance(); )
      t2.destroy();
    for (const t3 of vt.openers.keys())
      t3.removeEventListener("click", vt.fromEvent);
    vt.openers = /* @__PURE__ */ new Map();
  }
  static fromEvent(t2) {
    if (t2.defaultPrevented)
      return;
    if (t2.button && 0 !== t2.button)
      return;
    if (t2.ctrlKey || t2.metaKey || t2.shiftKey)
      return;
    let i2 = t2.composedPath()[0];
    const n2 = i2.closest("[data-fancybox-trigger]");
    if (n2) {
      const t3 = n2.dataset.fancyboxTrigger || "", e2 = document.querySelectorAll(`[data-fancybox="${t3}"]`), s3 = parseInt(n2.dataset.fancyboxIndex || "", 10) || 0;
      i2 = e2[s3] || i2;
    }
    if (!(i2 && i2 instanceof Element))
      return;
    let s2, o2, a2, r2;
    if ([...vt.openers].reverse().find(([t3, e2]) => !(!t3.contains(i2) || ![...e2].reverse().find(([e3, n3]) => {
      let l2 = i2.closest(e3);
      return !!l2 && (s2 = t3, o2 = e3, a2 = l2, r2 = n3, true);
    }))), !s2 || !o2 || !a2)
      return;
    r2 = r2 || {}, t2.preventDefault(), i2 = a2;
    let c2 = [], h2 = e({}, l, r2);
    h2.event = t2, h2.trigger = i2, h2.delegate = n2;
    const d2 = h2.groupAll, u2 = h2.groupAttr, p2 = u2 && i2 ? i2.getAttribute(`${u2}`) : "";
    if ((!i2 || p2 || d2) && (c2 = [].slice.call(s2.querySelectorAll(o2))), i2 && !d2 && (c2 = p2 ? c2.filter((t3) => t3.getAttribute(`${u2}`) === p2) : [i2]), !c2.length)
      return;
    const m2 = vt.getInstance();
    return m2 && m2.options.trigger && c2.indexOf(m2.options.trigger) > -1 ? void 0 : (i2 && (h2.startIndex = c2.indexOf(i2)), vt.fromNodes(c2, h2));
  }
  static fromNodes(t2, i2) {
    i2 = e({}, l, i2);
    const n2 = [];
    for (const e2 of t2) {
      const t3 = e2.dataset || {}, s2 = t3.src || e2.getAttribute("href") || e2.getAttribute("currentSrc") || e2.getAttribute("src") || void 0;
      let o2;
      const a2 = i2.delegate;
      let r2;
      a2 && n2.length === i2.startIndex && (o2 = a2 instanceof HTMLImageElement ? a2 : a2.querySelector("img:not([aria-hidden])")), o2 || (o2 = e2 instanceof HTMLImageElement ? e2 : e2.querySelector("img:not([aria-hidden])")), o2 && (r2 = o2.currentSrc || o2.src || void 0, !r2 && o2.dataset && (r2 = o2.dataset.lazySrc || o2.dataset.src || void 0));
      const l2 = { src: s2, triggerEl: e2, thumbEl: o2, thumbElSrc: r2, thumbSrc: r2 };
      for (const e3 in t3)
        "fancybox" !== e3 && (l2[e3] = t3[e3] + "");
      n2.push(l2);
    }
    return new vt(n2, i2);
  }
  static getInstance(t2) {
    if (t2)
      return gt.get(t2);
    return Array.from(gt.values()).reverse().find((t3) => !t3.isClosing() && t3) || null;
  }
  static getSlide() {
    var t2;
    return (null === (t2 = vt.getInstance()) || void 0 === t2 ? void 0 : t2.getSlide()) || null;
  }
  static show(t2 = [], e2 = {}) {
    return new vt(t2, e2);
  }
  static next() {
    const t2 = vt.getInstance();
    t2 && t2.next();
  }
  static prev() {
    const t2 = vt.getInstance();
    t2 && t2.prev();
  }
  static close(t2 = true, ...e2) {
    if (t2)
      for (const t3 of gt.values())
        t3.close(...e2);
    else {
      const t3 = vt.getInstance();
      t3 && t3.close(...e2);
    }
  }
};
Object.defineProperty(vt, "version", { enumerable: true, configurable: true, writable: true, value: "5.0.7" }), Object.defineProperty(vt, "defaults", { enumerable: true, configurable: true, writable: true, value: l }), Object.defineProperty(vt, "Plugins", { enumerable: true, configurable: true, writable: true, value: et }), Object.defineProperty(vt, "openers", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
export {
  vt as Fancybox
};
//# sourceMappingURL=@fancyapps_ui_dist_fancybox_fancybox__esm__js.js.map
